# A0140023E
###### /java/guitests/EditCommandTest.java
``` java
    @Test
    public void edit_invalidValues_failure() {
        // TODO constraints for date-time fields are also checked in other tests as they are constrained differently
        commandBox.runCommand("edit 1 //comments");
        assertResultMessage(Name.MESSAGE_NAME_CONSTRAINTS);

        commandBox.runCommand("edit 1 by yesterday");
        assertResultMessage(Deadline.MESSAGE_DEADLINE_CONSTRAINTS);

        commandBox.runCommand("edit 1 from yesterday to tmr");
        assertResultMessage(StartEndDateTime.MESSAGE_STARTDATETIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 from tmr to yesterday");
        assertResultMessage(StartEndDateTime.MESSAGE_ENDDATETIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 from 2 days later to 1 day later");
        assertResultMessage(StartEndDateTime.MESSAGE_STARTENDDATETIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 t/*&");
        assertResultMessage(Tag.MESSAGE_TAG_CONSTRAINTS);
    }

```
###### /java/guitests/EmptyDataTest.java
``` java
    @Test
    public void taskList_dataFileDoesNotExist_initEmptyTaskList() throws Exception {
        Task[] expectedList = new Task[0];
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
}
```
###### /java/onlythree/imanager/commons/util/StringUtilTest.java
``` java
    //---------------- Tests for replace --------------------------------------
    // TODO EP
    @Test
    public void replace_startIndexNegative_exceptionThrown() {
        assertOutOfBoundsExceptionThrown("01234", -1, 1, "Valid replacement");
    }

    // assertOutOfBoundsExceptionThrown("01234", 0, -1, "Valid replacement"); // negative end index

    @Test
    public void replace_startIndexLargerThanEndIndex_exceptionThrown() {
        assertOutOfBoundsExceptionThrown("01234", 1, 0, "Valid replacement");
    }
    // rename this method
    @Test
    public void replace_endIndexSuperLarge_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length(), 1000, "Valid replacement"), "01234Valid replacement");
    }

    // boundary value less than length by 1, length(), length() + 1
    @Test
    public void replace_startIndexLessThanLength_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length() - 1, s.length(), "Valid replacement"), "0123Valid replacement");
    }
    @Test
    public void replace_startIndexEqualToLength_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length(), s.length(), "Valid replacement"), "01234Valid replacement");
    }
    @Test
    public void replace_startIndexGreaterThanLength_exceptionThrown() {
        String s = "01234";
        assertOutOfBoundsExceptionThrown(s, s.length() + 1, 1, "Valid replacement");
    }

    @Test
    public void replace_withinBounds_expectedNewString() {
        assertEquals(StringUtil.replace("01234", 0, 1, "Valid replacement"), "Valid replacement1234");
    }

    private void assertOutOfBoundsExceptionThrown(String s, int startIndex, int endIndex, String replacement) {
        thrown.expect(StringIndexOutOfBoundsException.class);
        StringUtil.replace(s, startIndex, endIndex, replacement);
    }

}
```
###### /java/onlythree/imanager/logic/LogicManagerTest.java
``` java
    // TODO maybe to take out these tests and put elsewhere
    @Test
    public void execute_add_invalidTaskData() {
        assertCommandFailure("add invalid name with slash/ from tmr to 2 days after",
                Name.MESSAGE_NAME_CONSTRAINTS);
        assertCommandFailure("add valid name by yesterday t/validTag",
                Deadline.MESSAGE_DEADLINE_CONSTRAINTS);
        assertCommandFailure("add valid name from yesterday to tmr t/validTag",
                StartEndDateTime.MESSAGE_STARTDATETIME_CONSTRAINTS);
        assertCommandFailure("add valid name from tmr to yesterday t/validTag",
                StartEndDateTime.MESSAGE_ENDDATETIME_CONSTRAINTS);
        assertCommandFailure("add valid name from 3 days later to 2 days later t/validTag",
                StartEndDateTime.MESSAGE_STARTENDDATETIME_CONSTRAINTS);
        assertCommandFailure("add Valid Name from 2 days later to 3 days later t/invalid_-[.tag",
                Tag.MESSAGE_TAG_CONSTRAINTS);
    }

```
###### /java/onlythree/imanager/logic/LogicManagerTest.java
``` java
        // TODO should this be done in another way?
        // Starting Test Date Time is set to one day after today so that dates in the past is not
        // generated to prevent a PastDateTimeException from occuring. Furthermore the precision
        // is truncated to seconds as Natty does not parse milliseconds
        private ZonedDateTime startTestDateTime = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS).plusDays(1);

        private Task accept() throws Exception {
            Name name = new Name("Accept Changes");
            StartEndDateTime startEndDateTime =
                    new StartEndDateTime(startTestDateTime.plusDays(2), startTestDateTime.plusDays(4));
            Tag tag1 = new Tag("tag1");
            Tag tag2 = new Tag("longertag2");
            UniqueTagList tags = new UniqueTagList(tag1, tag2);
            // Note that a task is generated with a StartEndDateTime as that would be more complex
            // than a task with Deadline or a Task with no Deadline and StartEndDateTime, thus
            // making test cases more likely to fail
            return new Task(name, Optional.empty(), Optional.of(startEndDateTime), tags);
        }

        /**
         * Generates a valid task using the given seed.
         * Running this function with the same parameter values guarantees the returned task will have the same state
         * if it is using the same instance of {@link TestDataHelper}.
         * Each unique seed will generate a unique task object.
         *
         * @param seed used to generate the task data field values
         */
        private Task generateTaskWithStartEndDateTime(int seed) throws Exception {
            return new Task(
                    new Name("Task" + seed),
                    Optional.empty(),
                    Optional.of(new StartEndDateTime(startTestDateTime.plusDays(seed + 1),
                            startTestDateTime.plusDays(seed + 2))),
                    new UniqueTagList(new Tag("tag" + Math.abs(seed)), new Tag("tag" + Math.abs(seed + 1)))
            );
        }

        /** Generates the correct add command based on the task given */
        private String generateAddCommand(Task task) {
            // The date-times are transformed into a format that Natty can parse
            StringBuffer cmd = new StringBuffer();

            cmd.append("add ");

            cmd.append(task.getName().toString());

            if (task.getDeadline().isPresent()) {
                cmd.append(" by ");
                cmd.append(task.getDeadline().get().getDateTime().format(DateTimeFormats.TEST_FORMAT));
            }

            if (task.getStartEndDateTime().isPresent()) {
                StartEndDateTime startEndDateTime = task.getStartEndDateTime().get();
                cmd.append(" from ");
                cmd.append(startEndDateTime.getStartDateTime().format(DateTimeFormats.TEST_FORMAT));
                cmd.append(" to ");
                cmd.append(startEndDateTime.getEndDateTime().format(DateTimeFormats.TEST_FORMAT));
            }

            UniqueTagList tags = task.getTags();
            for (Tag t: tags) {
                cmd.append(" t/").append(t.tagName);
            }

            return cmd.toString();
        }

```
###### /java/onlythree/imanager/logic/LogicManagerTest.java
``` java
        /**
         * Generates a Task object with given name. Other fields will have some dummy values.
         */
        private Task generateTaskWithName(String name) throws Exception {
            // Note that a task is generated with a StartEndDateTime as that would be more complex
            // than a task with Deadline or a Task with no Deadline and StartEndDateTime, thus
            // making test cases more likely to fail
            return new Task(
                    new Name(name),
                    Optional.empty(),
                    Optional.of(new StartEndDateTime(startTestDateTime.plusDays(3), startTestDateTime.plusDays(6))),
                    new UniqueTagList(new Tag("tag"))
            );
        }
    }
}
```
###### /java/onlythree/imanager/logic/parser/AddCommandParserTest.java
``` java
public class AddCommandParserTest {
    // TODO make logicmanagertest test some simple add and edit
    // TODO fixed dates like 25 Apr can fail if it is in the past
    // TODO see who else is using ExpectedException
    // TODO fuzzy equals

    @Rule
    public ExpectedException exception = ExpectedException.none();

    private static Task actualTask;

    //TODO
    @Test
    public void testAdd() throws PastDateTimeException, IllegalValueException, CommandException {
        Name name = new Name("stand by me");
        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(1).truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(name, Optional.of(deadline), Optional.empty(), new UniqueTagList());

        Command command = new AddCommandParser().parse("stand by me by tmr");
        command.setData(new ModelManagerMock());
        CommandResult result = command.execute();
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));
        assertEquals(expectedTask, actualTask);
        System.out.println(actualTask);
        System.out.println(result.feedbackToUser);
    }


    @Test
    public void testEdit() throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        editTaskCommand(model, "1 by 2 days later");

        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(2).truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }

    @Test
    public void testEdit2() throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();
        addSampleTaskWithDeadline(model);

        editTaskCommand(model, "1 Pass rose from Uncle to Jane by 5 days later");

        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(5).truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(new Name("Pass rose from Uncle to Jane"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }

    @Test
    public void testEdit3() throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        editTaskCommand(model, "1 by 8 days from 25 Apr");

        Deadline deadline = new Deadline(ZonedDateTime.now().withMonth(4).withDayOfMonth(25).plusDays(8)
                .truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }


    @Test
    public void testEditSpecial1() throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        exception.expect(CommandException.class);
        exception.expectMessage(EditCommand.EditTaskDescriptor.MESSAGE_NEED_START_END_DATE_TIME);

        editTaskCommand(model, "1 by 8 days later from 25 Apr");

        Deadline deadline = new Deadline(ZonedDateTime.now().withMonth(4).withDayOfMonth(25).plusDays(8)
                .truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }

    @Test
    public void testEditSpecial2()
            throws PastDateTimeException, InvalidDurationException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithStartEndDateTime(model);

        editTaskCommand(model, "1 by 8 days later from 25 Apr");

        ZonedDateTime startDateTime =
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).truncatedTo(ChronoUnit.MINUTES);
        ZonedDateTime endDateTime =
                ZonedDateTime.now().withMonth(4).withDayOfMonth(28).truncatedTo(ChronoUnit.MINUTES);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime);
        Task expectedTask = new Task(new Name("by 8 days later"), Optional.empty(), Optional.of(startEndDateTime),
                new UniqueTagList());

        StartEndDateTime actualStartEndDateTime = actualTask.getStartEndDateTime().get();
        actualTask.setStartEndDateTime(new StartEndDateTime(
                actualStartEndDateTime.getStartDateTime().truncatedTo(ChronoUnit.MINUTES),
                actualStartEndDateTime.getEndDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }

    private void addSampleTaskWithDeadline(Model model) throws CommandException {
        Command command = new AddCommandParser().parse("stand by me by tmr");
        command.setData(model);
        command.execute();
    }

    private void addSampleTaskWithStartEndDateTime(Model model) throws CommandException {
        Command command = new AddCommandParser().parse("stand by me from 23 Apr to 28 Apr");
        command.setData(model);
        command.execute();
    }

    private void editTaskCommand(Model model, String args) throws CommandException {
        Command command = new EditCommandParser().parse(args);
        command.setData(model);
        command.execute();
    }

    private class ModelManagerMock extends ModelManager {
        @Override
        public synchronized void addTask(Task task) {
            AddCommandParserTest.actualTask = task;
            super.addTask(task);
        }

        // TODO move this to EditCommandParserTest
        @Override
        public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) {
            try {
                AddCommandParserTest.actualTask = new Task(editedTask);
            } catch (IllegalValueException e) {
                throw new AssertionError("Copying a valid task should always result in a valid task");
            }
            super.updateTask(filteredTaskListIndex, editedTask);
        }
    }

}
```
###### /java/onlythree/imanager/logic/parser/DateTimeUtilTest.java
``` java
// TODO improve test and naming
public class DateTimeUtilTest {
    @Rule
    public final ExpectedException exception = ExpectedException.none();

    @Test
    public void parseDateTimeString_validDateTimes_noExceptionThrown() throws IllegalValueException {
        //org.apache.log4j.Logger.getRootLogger().setLevel(Level.INFO);

        // Random days of the week
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.SATURDAY)),
                DateTimeUtil.parseDateTimeString("Sat"));
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.WEDNESDAY)),
                DateTimeUtil.parseDateTimeString("Wed"));
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.FRIDAY)),
                DateTimeUtil.parseDateTimeString("Fri"));

        // Random date with month
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withMonth(4).withDayOfMonth(25),
                DateTimeUtil.parseDateTimeString("25 Apr"));

        // Random month with year, Natty infers that it's 1st day of month
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withYear(2017).withMonth(1).withDayOfMonth(1),
                DateTimeUtil.parseDateTimeString("Jan 2017"));

        // Random relative date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusDays(2),
                DateTimeUtil.parseDateTimeString("2 days after"));

        // Random explicit date
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(LocalDate.of(2016, 5, 2), LocalTime.now(), DateTimeFormats.SYSTEM_TIME_ZONE),
                DateTimeUtil.parseDateTimeString("2016-05-02"));
    }

    @Test
    public void parseDateTimeString_invalidDateTime_throwsException() throws IllegalValueException {
        assertInvalidDateTime("Not a date");
    }
    @Test
    public void parseDateTimeString_invalidDateTimeWithSymbols_throwsException() throws IllegalValueException {
        assertInvalidDateTime("We.d");
    }

    @Test
    public void parseDateTimeString_multipleDateTimes_throwsException() throws IllegalValueException {
        assertMultipleDateTimesFound("Wed ~ Thur");
    }

    @Test
    public void parseDateTimeString_multipleDateTimeAlternatives_throwsException() throws IllegalValueException {
        assertMultipleDateTimeAlternativesFound("Wed or Thur");
    }
    @Test
    public void parseDateTimeString_recurringDateTime_throwsException() throws IllegalValueException {
        assertRecurringDateTimesFound("every Friday");
    }

    public void assertInvalidDateTime(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_NOT_VALID_DATE_TIME, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    public void assertMultipleDateTimesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_MULTIPLE_DATE_TIMES_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    public void assertMultipleDateTimeAlternativesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_MULTIPLE_DATE_TIME_ALTERNATIVES_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    public void assertRecurringDateTimesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_RECURRING_DATE_TIME_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    @Test
    public void isSingleDateTimeString() {
        // Not dates
        assertFalse(DateTimeUtil.isSingleDateTimeString("Hello World"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Not a date"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("We.d"));

        // multiple date groups separated by unknown tokens
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed ~ Thursday"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed ` Thursday"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed plus Thursday"));

        // recurring dates
        assertFalse(DateTimeUtil.isSingleDateTimeString("every Friday"));

        // multiple date alternatives
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed or Thur"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed and Thur"));


        // valid single dates
        assertTrue(DateTimeUtil.isSingleDateTimeString("Sat"));
    }

    // TODO all these also
    @Test
    public void testingOnly() throws IllegalValueException {
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusDays(2),
                DateTimeUtil.parseDateTimeString("2 days after 8pm 25 Apr"));

        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusHours(2),
                DateTimeUtil.parseDateTimeString("2 hours after 8pm 25 Apr"));

    }

    @Test
    public void parseEditedDateTimeString() throws IllegalValueException {
        ZoneId fixedRandomZoneId = ZoneId.of("Asia/Tokyo");
        ZonedDateTime fixedRandomDateTime = ZonedDateTime.of(2015, 4, 1, 3, 4, 5, 2, fixedRandomZoneId);

        // relative date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days later", fixedRandomDateTime));
        // relative time
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusHours(24),
                DateTimeUtil.parseEditedDateTimeString("24 hours later", fixedRandomDateTime));

        // relative date respective to another date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withMonth(4).withDayOfMonth(25).plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days after 25 Apr", fixedRandomDateTime));

        // relative date respective to another date-time
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days after 25 Apr 8pm", fixedRandomDateTime));

        // relative date respective to another date-time with time-zone
        // PST and America/Los_Angeles is equivalent but Natty supports only certain time-zone suffixes
        // PST is an example of daylights saving time
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("America/Los_Angeles"))
                        .plusDays(5),
                DateTimeUtil.parseEditedDateTimeString("5 days after 25 Apr 8pm PST", fixedRandomDateTime));

        // relative date respective to another date-time with time-zone offset
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("+1000"))
                        .plusDays(3),
                DateTimeUtil.parseEditedDateTimeString("3 days after 25 Apr 8pm +1000", fixedRandomDateTime));


        // relative date respective to another date with time
        // note that this does not work because Natty is not working correctly
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusHours(2),
                DateTimeUtil.parseEditedDateTimeString("2 hours after 25 Apr 8pm", fixedRandomDateTime));
        // TODO
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("America/Los_Angeles"))
                        .plusDays(5),
                DateTimeUtil.parseEditedDateTimeString("5 days after 8pm PST 25 Apr", fixedRandomDateTime));
    }

    // Extract this for use in other tests
    /**
     * Asserts that two zoned date-times are equal ignoring milliseconds and below.
     */
    private void assertEqualsIgnoresMilliAndBelow(ZonedDateTime expected, ZonedDateTime actual) {
        ChronoUnit truncationUnit = ChronoUnit.SECONDS;
        ZonedDateTime expectedTruncated = expected.truncatedTo(truncationUnit);
        ZonedDateTime actualTruncated = actual.truncatedTo(truncationUnit);
        assertIsEqual(expectedTruncated, actualTruncated);
    }

    /**
     * Asserts that two zoned date-times are not equal ignoring milliseconds and below.
     */
    private void assertNotEqualsIgnoresMilliAndBelow(ZonedDateTime expected, ZonedDateTime actual) {
        ChronoUnit truncationUnit = ChronoUnit.SECONDS;
        ZonedDateTime expectedTruncated = expected.truncatedTo(truncationUnit);
        ZonedDateTime actualTruncated = actual.truncatedTo(truncationUnit);
        assertIsNotEqual(expectedTruncated, actualTruncated);
    }

    /**
     * Assert that the instant of the ZonedDateTimes are equal instead of comparing component by component.
     * @see ChronoZonedDateTime#isEqual(ChronoZonedDateTime)
     */
    private void assertIsEqual(ZonedDateTime expected, ZonedDateTime actual) {
        assertEquals(expected.toInstant(), actual.toInstant());
    }

    /**
     * Assert that the instant of the ZonedDateTimes are not equal instead of comparing component by component.
     * @see ChronoZonedDateTime#isEqual(ChronoZonedDateTime)
     */
    private void assertIsNotEqual(ZonedDateTime expected, ZonedDateTime actual) {
        assertNotEquals(expected.toInstant(), actual.toInstant());
    }
}
```
###### /java/onlythree/imanager/model/task/NameTest.java
``` java
    @Test
    public void isValidName() {
        // invalid name
        assertFalse(Name.isValidName("")); // empty string
        assertFalse(Name.isValidName(" ")); // space only (0x20)
        assertFalse(Name.isValidName("\t")); // tab only
        assertFalse(Name.isValidName("\n")); // new line only
        assertFalse(Name.isValidName("\u000B")); // Vertical tab only
        assertFalse(Name.isValidName("\f")); // form feed only
        assertFalse(Name.isValidName("\r")); // carriage return only
        assertFalse(Name.isValidName("//")); // only slashes
        assertFalse(Name.isValidName("fetch colleague/boss")); // contains forward slashes

        // valid name
        assertTrue(Name.isValidName("assignment")); // alphabets only
        assertTrue(Name.isValidName("12345")); // numbers only
        assertTrue(Name.isValidName("2nd draft")); // alphanumeric characters
        assertTrue(Name.isValidName("Software Engineering Exam")); // with capital letters
        assertTrue(Name.isValidName("Super duper the long task")); // long names
        assertTrue(Name.isValidName("#$!$#!$!@#$!@!~@~!")); // tons of random symbols
        assertTrue(Name.isValidName("Whee~~~~")); // alphabets with symbols
        assertTrue(Name.isValidName("Omg!!")); // alphabets with symbols
        assertTrue(Name.isValidName("你好吗?")); // Valid UTF-16 string with symbols
    }
}
```
###### /java/onlythree/imanager/testutil/TaskBuilder.java
``` java
/**
 * A Task Builder class that allow us to construct a Task by chaining calls for convenience in testing.
 */
```
###### /java/onlythree/imanager/testutil/TaskBuilder.java
``` java
    public TaskBuilder withDeadline(Deadline deadline) {
        task.setDeadline(deadline);
        return this;
    }

    public TaskBuilder withStartEndDateTime(StartEndDateTime startEndDateTime) {
        task.setStartEndDateTime(startEndDateTime);
        return this;
    }

```
###### /java/onlythree/imanager/testutil/TaskBuilder.java
``` java
    public TaskBuilder withComplete(boolean isComplete) {
        task.setComplete(isComplete);
        return this;
    }

```
###### /java/onlythree/imanager/testutil/TestTask.java
``` java
    public TestTask() {
        // Initialize TestTask with empty deadlines, startEndDateTime and tags because they are optional.
        // this will allow us to conveniently create TestTasks through TaskBuilder without being forced
        // to specify the optional fields
        deadline = Optional.empty();
        startEndDateTime = Optional.empty();
        tags = new UniqueTagList();
        complete = false;
    }

    /**
     * Creates a copy of {@code taskToCopy} by shallow copying only the data.
     * Shallow copying reduces the overhead of copying the data.
     */
    public TestTask(TestTask taskToCopy) {
        name = taskToCopy.getName();
        deadline = taskToCopy.getDeadline();
        startEndDateTime = taskToCopy.getStartEndDateTime();
        tags = taskToCopy.getTags();
        complete = taskToCopy.isComplete();
    }

```
###### /java/onlythree/imanager/testutil/TestTask.java
``` java
    @Override
    public Optional<Deadline> getDeadline() {
        return deadline;
    }

    @Override
    public Optional<StartEndDateTime> getStartEndDateTime() {
        return startEndDateTime;
    }

```
###### /java/onlythree/imanager/testutil/TestTask.java
``` java
    public void setDeadline(Deadline dateTime) {
        this.deadline = Optional.of(dateTime);
    }

    public void setStartEndDateTime(StartEndDateTime startEndDateTime) {
        this.startEndDateTime = Optional.of(startEndDateTime);
    }

```
###### /java/onlythree/imanager/testutil/TestTask.java
``` java
    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + getName().value + " ");

        if (getDeadline().isPresent()) {
            sb.append(" by ");
            sb.append(getDeadline().get().getDateTime().format(DateTimeFormats.TEST_FORMAT));
        }

        if (getStartEndDateTime().isPresent()) {
            StartEndDateTime startEndDateTime = getStartEndDateTime().get();
            sb.append(" from ");
            sb.append(startEndDateTime.getStartDateTime().format(DateTimeFormats.TEST_FORMAT));
            sb.append(" to ");
            sb.append(startEndDateTime.getEndDateTime().format(DateTimeFormats.TEST_FORMAT));
        }

        getTags().asObservableList().stream().forEach(s -> sb.append("t/" + s.tagName + " "));
        return sb.toString();
    }
}
```
###### /java/onlythree/imanager/testutil/TestUtil.java
``` java
    private static Task[] getSampleTaskData() {
        try {
            // TODO maybe they should not be empty optionals
            return new Task[]{
                new Task(new Name("Allocate Work"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Buy Groceries"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Count doomsday"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Die tomorrow"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Elicit crap"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Fool around"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Goof around"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Help someone"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Improve tasks"), Optional.empty(), Optional.empty(), new UniqueTagList())
            };
            //CHECKSTYLE.ON: LineLength
        } catch (IllegalValueException e) {
            throw new AssertionError("The sample tasks should meet all the constraints");
        }
    }


    private static Tag[] getSampleTagData() {
        try {
            return new Tag[]{
                new Tag("meeting"),
                new Tag("project")
            };
        } catch (IllegalValueException e) {
            throw new AssertionError("The sample tag should meet the constraints");
        }
    }

```
###### /java/onlythree/imanager/testutil/TypicalTestTasks.java
``` java
    // TODO naming of tasks as names does not seem to be a good idea, and not descriptive enough
    // for example helpMe and iAmCode are to be manually added in test cases but it is not clear
    // conversely the name shows what the task contains, so it can be helpful
    public TestTask amuseFriend, bet, count, dog, elephant, flipTable, goondu, helpMe, iAmCode;

    public TypicalTestTasks() {
        // Starting Test Date Time is set to one day after today so that dates in the past is not
        // generated to prevent a PastDateTimeException from occuring. Furthermore the precision
        // is truncated to seconds as Natty does not parse milliseconds
        ZonedDateTime startTestDateTime = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS).plusDays(1);
        try {
            // floating task with a tag
            amuseFriend = new TaskBuilder().withName("Amuse friend").withTags("friends").build();
            // Notice how flipping the order of tags and test cases can fail, see TestUtil::compareCardAndTask
            // using list compare instead of set compare
            // floating task with two tags
            bet = new TaskBuilder().withName("Bet dog race").withTags("luck", "money").build();
            // floating task with no tags
            count = new TaskBuilder().withName("Count chickens before they hatch").build();
            // task with deadlines
            dog = new TaskBuilder().withName("Dog naming")
                    .withDeadline(new Deadline(startTestDateTime.plusDays(3))).build();
            // task with start and end dates
            elephant = new TaskBuilder().withName("Elephant riding")
                    .withStartEndDateTime(new StartEndDateTime(startTestDateTime.plusHours(2),
                                                               startTestDateTime.plusHours(3)))
                    .build();
            // some other random floating tasks
            flipTable = new TaskBuilder().withName("Flip table").build();
            goondu = new TaskBuilder().withName("Goondu goon").build();

            // Manually added
            // TODO maybe to use non-floating tasks here
            helpMe = new TaskBuilder().withName("Help me").build();
            iAmCode = new TaskBuilder().withName("I am code").build();
        } catch (PastDateTimeException e) {
            throw new AssertionError("The typical test tasks should not be built with date-times in the past");
        } catch (InvalidDurationException e) {
            throw new AssertionError("The typical test tasks should not be built with an invalid duration period");
        } catch (IllegalValueException e) {
            throw new AssertionError("The typical test tasks should already meet all the constraints required");
        }
    }

    public static void loadTaskListWithSampleData(TaskList taskList) {
        for (TestTask task : new TypicalTestTasks().getTypicalTasks()) {
            try {
                taskList.addTask(new Task(task));
            } catch (IllegalValueException e) {
                throw new AssertionError("Copying a valid task should always result in a valid task.");
            }
        }
    }

    public TestTask[] getTypicalTasks() {
        return new TestTask[]{amuseFriend, bet, count, dog, elephant, flipTable, goondu};
    }

```
