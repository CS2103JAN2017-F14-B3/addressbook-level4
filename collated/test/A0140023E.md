# A0140023E
###### /java/seedu/address/logic/LogicManagerTest.java
``` java
        // TODO should this be done in another way?
        // Starting Test Date Time is set to one day after today so that dates in the past is not
        // generated to prevent a PastDateTimeException from occuring. Furthermore the precision
        // is truncated to seconds as Natty does not parse milliseconds
        private ZonedDateTime startTestDateTime = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS).plusDays(1);

        Task accept() throws Exception {
            Name name = new Name("Accept Changes");
            StartEndDateTime startEndDateTime =
                    new StartEndDateTime(startTestDateTime.plusDays(2), startTestDateTime.plusDays(4));
            Tag tag1 = new Tag("tag1");
            Tag tag2 = new Tag("longertag2");
            UniqueTagList tags = new UniqueTagList(tag1, tag2);
            // Note that a task is generated with a StartEndDateTime as that would be more complex
            // than a task with Deadline or a Task with no Deadline and StartEndDateTime, thus
            // making test cases more likely to fail
            return new Task(name, Optional.empty(), Optional.of(startEndDateTime), tags);
        }

        /**
         * Generates a valid task using the given seed.
         * Running this function with the same parameter values guarantees the returned task will have the same state.
         * Each unique seed will generate a unique task object.
         *
         * @param seed used to generate the task data field values
         */
        Task generateTask(int seed) throws Exception {
            // note to change
            return new Task(
                    new Name("Task" + seed),
                    Optional.of(new Deadline(startTestDateTime.plusDays(seed))),
                    Optional.of(new StartEndDateTime(startTestDateTime.plusDays(seed + 1),
                            startTestDateTime.plusDays(seed + 2))),
                    new UniqueTagList(new Tag("tag" + Math.abs(seed)), new Tag("tag" + Math.abs(seed + 1)))
            );
        }

        /** Generates the correct add command based on the task given */
        String generateAddCommand(Task task) {
            StringBuffer cmd = new StringBuffer();

            cmd.append("add ");

            cmd.append(task.getName().toString());

            if (task.getDeadline().isPresent()) {
                cmd.append(" by ");
                // TODO change the format
                cmd.append(task.getDeadline().get().getValue().format(ParserUtil.DATE_TIME_FORMAT));
            }

            if (task.getStartEndDateTime().isPresent()) {
                // TODO change the format
                StartEndDateTime startEndDateTime = task.getStartEndDateTime().get();
                cmd.append(" from ");
                cmd.append(startEndDateTime.getStartDateTime().format(ParserUtil.DATE_TIME_FORMAT));
                cmd.append(" to ");
                cmd.append(startEndDateTime.getEndDateTime().format(ParserUtil.DATE_TIME_FORMAT));
            }

            UniqueTagList tags = task.getTags();
            for (Tag t: tags) {
                cmd.append(" t/").append(t.tagName);
            }

            return cmd.toString();
        }

```
###### /java/seedu/address/logic/LogicManagerTest.java
``` java
        /**
         * Generates a Task object with given name. Other fields will have some dummy values.
         */
        Task generateTaskWithName(String name) throws Exception {
            // Note that a task is generated with a StartEndDateTime as that would be more complex
            // than a task with Deadline or a Task with no Deadline and StartEndDateTime, thus
            // making test cases more likely to fail
            return new Task(
                    new Name(name),
                    Optional.empty(),
                    Optional.of(new StartEndDateTime(startTestDateTime.plusDays(3), startTestDateTime.plusDays(6))),
                    new UniqueTagList(new Tag("tag"))
            );
        }
    }
}
```
###### /java/seedu/address/testutil/TaskBuilder.java
``` java
/**
 * A Task Builder class that allow us to construct a Task by chaining calls for convenience in testing.
 */
```
###### /java/seedu/address/testutil/TaskBuilder.java
``` java
    public TaskBuilder withDeadline(Deadline deadline) throws IllegalValueException {
        task.setDeadline(deadline);
        return this;
    }

    public TaskBuilder withStartEndDateTime(StartEndDateTime startEndDateTime) throws IllegalValueException {
        task.setStartEndDateTime(startEndDateTime);
        return this;
    }

```
###### /java/seedu/address/testutil/TestTask.java
``` java
    public TestTask() {
        // Initialize TestTask with empty deadlines, startEndDateTime and tags because they are optional.
        // this will allow us to conveniently create TestTasks through TaskBuilder without being forced
        // to specify the optional fields
        deadline = Optional.empty();
        startEndDateTime = Optional.empty();
        tags = new UniqueTagList();
    }

    /**
     * Creates a copy of {@code taskToCopy} by shallow copying only the data.
     * Shallow copying reduces the overhead of copying the data.
     */
    public TestTask(TestTask taskToCopy) {
        name = taskToCopy.getName();
        deadline = taskToCopy.getDeadline();
        startEndDateTime = taskToCopy.getStartEndDateTime();
        tags = taskToCopy.getTags();
    }

```
###### /java/seedu/address/testutil/TestTask.java
``` java
    public void setDeadline(Deadline dateTime) {
        this.deadline = Optional.of(dateTime);
    }

    public void setStartEndDateTime(StartEndDateTime startEndDateTime) {
        this.startEndDateTime = Optional.of(startEndDateTime);
    }

```
###### /java/seedu/address/testutil/TestTask.java
``` java
    @Override
    public Optional<Deadline> getDeadline() {
        return deadline;
    }

    @Override
    public Optional<StartEndDateTime> getStartEndDateTime() {
        return startEndDateTime;
    }

```
###### /java/seedu/address/testutil/TestTask.java
``` java
    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + getName().value + " ");

        if (getDeadline().isPresent()) {
            sb.append(" by ");
            // TODO change the format
            sb.append(getDeadline().get().getValue().format(ParserUtil.DATE_TIME_FORMAT));
        }

        if (getStartEndDateTime().isPresent()) {
            // TODO change the format
            StartEndDateTime startEndDateTime = getStartEndDateTime().get();
            sb.append(" from ");
            sb.append(startEndDateTime.getStartDateTime().format(ParserUtil.DATE_TIME_FORMAT));
            sb.append(" to ");
            sb.append(startEndDateTime.getEndDateTime().format(ParserUtil.DATE_TIME_FORMAT));
        }

        getTags().asObservableList().stream().forEach(s -> sb.append("t/" + s.tagName + " "));
        return sb.toString();
    }
}
```
###### /java/seedu/address/testutil/TypicalTestTasks.java
``` java
    public TypicalTestTasks() {
        // Starting Test Date Time is set to one day after today so that dates in the past is not
        // generated to prevent a PastDateTimeException from occuring. Furthermore the precision
        // is truncated to seconds as Natty does not parse milliseconds
        ZonedDateTime startTestDateTime = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS).plusDays(1);
        try {
            // floating task with a tag
            amuseFriend = new TaskBuilder().withName("Amuse friend").withTags("friends").build();
            // TODO flip the order of tags and test cases can fail, see TestUtil::compareCardAndPerson
            // using list compare instead of set compare
            // floating task with two tags
            bet = new TaskBuilder().withName("Bet dog race").withTags("luck", "money").build();
            // floating task with no tags
            count = new TaskBuilder().withName("Count chickens before they hatch").build();
            // task with deadlines
            dog = new TaskBuilder().withName("Dog naming")
                    .withDeadline(new Deadline(startTestDateTime.plusDays(3))).build();
            // task with start and end dates
            elephant = new TaskBuilder().withName("Elephant riding")
                    .withStartEndDateTime(new StartEndDateTime(startTestDateTime.plusHours(2),
                                                               startTestDateTime.plusHours(3)))
                    .build();
            // some other random floating tasks
            flipTable = new TaskBuilder().withName("Flip table").build();
            goondu = new TaskBuilder().withName("Goondu goon").build();

            // Manually added
            // TODO maybe to use non-floating tasks here
            helpMe = new TaskBuilder().withName("Help me").build();
            iAmCode = new TaskBuilder().withName("I am code").build();
        } catch (PastDateTimeException e) {
            e.printStackTrace();
            assert false : "not possible";
        } catch (InvalidDurationException e) {
            e.printStackTrace();
            assert false : "not possible";
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

```
