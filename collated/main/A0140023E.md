# A0140023E
###### /java/seedu/address/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values except {@code deadline} and {@code startEndDateTime}
     * that must be pre-initialized.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String nameArgs, Optional<Deadline> deadline,
            Optional<StartEndDateTime> startEndDateTime, Set<String> tags) throws IllegalValueException {
        toAdd = new Task(new Name(nameArgs), deadline, startEndDateTime, initTagList(tags));
    }

    /**
     * Returns initialized tags as a {@link UniqueTagList}
     * @throws IllegalValueException if there is a tag name that is invalid in the given tags set
     */
    private UniqueTagList initTagList(Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        return new UniqueTagList(tagSet);
    }

```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        //Task editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
        try {
            editTaskDescriptor.processFields(taskToEdit);
        } catch (PastDateTimeException e) {
            throw new CommandException(e.getMessage());
        } catch (InvalidDurationException e) {
            throw new CommandException(e.getMessage());
        } catch (IllegalValueException e) {
            throw new CommandException(e.getMessage());
        }

        // TODO convert to exception like a NoFieldEditedException
        if (!this.editTaskDescriptor.isAnyFieldEdited()) {
            throw new CommandException(EditCommand.MESSAGE_NOT_EDITED);
        }

        Name updatedName = editTaskDescriptor.getUpdatedName();
        Optional<Deadline> updatedDeadline = editTaskDescriptor.getDeadline(); // getUpdatedDeadline
        // getUpdatedStartEndDateTime
        Optional<StartEndDateTime> updatedStartEndDateTime = editTaskDescriptor.getStartEndDateTime();
        UniqueTagList updatedTagList = editTaskDescriptor.getUpdatedTagList();

        Task editedTask = new Task(updatedName, updatedDeadline, updatedStartEndDateTime, updatedTagList);

        try {
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<Deadline> deadline = Optional.empty();
        private Optional<StartEndDateTime> startEndDateTime = Optional.empty();
        private Optional<UniqueTagList> tagList = Optional.empty();

        private Optional<String> rawDeadline;
        private Optional<String> rawStartDateTime;
        private Optional<String> rawEndDateTime;

        private Name updatedName;
        private UniqueTagList updatedTagList;

        public EditTaskDescriptor() {}

        public void processFields(ReadOnlyTask taskToEdit)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            updatedName = getName().orElseGet(taskToEdit::getName);

            if (getRawDeadline().isPresent()) {
                if (taskToEdit.getDeadline().isPresent()) {
                    // Bubble up the exception
                    deadline = ParserUtil.parseEditedDeadline(getRawDeadline(), taskToEdit.getDeadline().get());
                } else {
                    deadline = ParserUtil.parseNewDeadline(getRawDeadline());
                }
            } else {
                deadline = taskToEdit.getDeadline();
            }

            startEndDateTime = Optional.empty();
            if (getRawStartDateTime().isPresent() && !getRawEndDateTime().isPresent()) {
                // TODO remove println
                System.out.println("From only!");
                if (taskToEdit.getStartEndDateTime().isPresent()) {
                    // TODO should we wrap this into ParserUtil as well?
                    final StartEndDateTime editedTaskStartEndDateTime = taskToEdit.getStartEndDateTime().get();
                    ZonedDateTime startDateTime =
                            ParserUtil.parseEditedDateTimeString(getRawStartDateTime().get(),
                                    editedTaskStartEndDateTime.getStartDateTime());
                    startEndDateTime = Optional.of(new StartEndDateTime(startDateTime,
                            editedTaskStartEndDateTime.getEndDateTime()));
                } else {
                    // TODO message change
                    throw new IllegalValueException("Start Date must comes with an End Date");
                }
            } else if (!getRawStartDateTime().isPresent() && getRawEndDateTime().isPresent()) {
                // TODO remove println
                System.out.println("To only!");
                if (taskToEdit.getStartEndDateTime().isPresent()) {
                    // TODO should we wrap this into ParserUtil as well?
                    final StartEndDateTime editedTaskStartEndDateTime = taskToEdit.getStartEndDateTime().get();
                    ZonedDateTime endDateTime =
                            ParserUtil.parseEditedDateTimeString(getRawEndDateTime().get(),
                                    editedTaskStartEndDateTime.getEndDateTime());
                    startEndDateTime = Optional.of(
                            new StartEndDateTime(editedTaskStartEndDateTime.getStartDateTime(), endDateTime));
                } else {
                    // TODO message change
                    throw new IllegalValueException("End Date must come with a Start Date");
                }
            } else if (getRawStartDateTime().isPresent() && getRawEndDateTime().isPresent()) {
                if (taskToEdit.getStartEndDateTime().isPresent()) {
                    startEndDateTime =
                            ParserUtil.parseEditedStartEndDateTime(getRawStartDateTime(), getRawEndDateTime(),
                                    taskToEdit.getStartEndDateTime().get());
                } else {
                    startEndDateTime =
                            ParserUtil.parseNewStartEndDateTime(getRawStartDateTime(), getRawEndDateTime());
                }
            } else {
                startEndDateTime = taskToEdit.getStartEndDateTime();
            }
            updatedTagList = getTagList().orElseGet(taskToEdit::getTags);

        }

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            name = toCopy.getName();
            deadline = toCopy.getDeadline();
            startEndDateTime = toCopy.getStartEndDateTime();
            tagList = toCopy.getTagList();

            rawDeadline = toCopy.getRawDeadline();
            rawStartDateTime = toCopy.getRawStartDateTime();
            rawEndDateTime = toCopy.getRawEndDateTime();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            // TODO note that we ignore raw fields because they are not important
            return CollectionUtil.isAnyPresent(name, deadline, startEndDateTime, tagList);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        // get updated
        public Optional<Deadline> getDeadline() {
            return deadline;
        }
        // get updated
        public Optional<StartEndDateTime> getStartEndDateTime() {
            return startEndDateTime;
        }


        public void setRawDeadline(Optional<String> rawDeadline) {
            this.rawDeadline = rawDeadline;

        }

        public void setRawStartDateTime(Optional<String> value) {
            rawStartDateTime = value;
        }

        public void setRawEndDateTime(Optional<String> value) {
            rawEndDateTime = value;
        }

        public Optional<String> getRawDeadline() {
            return rawDeadline;
        }

        public Optional<String> getRawStartDateTime() {
            return rawStartDateTime;
        }

        public Optional<String> getRawEndDateTime() {
            return rawEndDateTime;
        }


        public Optional<UniqueTagList> getTagList() {
            return tagList;
        }

        public void setTagList(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tagList = tags;
        }

        public Name getUpdatedName() {
            return updatedName;
        }

        public UniqueTagList getUpdatedTagList() {
            return updatedTagList;
        }

    }
}
```
###### /java/seedu/address/logic/parser/AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        DateTimeExtractor dateTimeExtractor = new DateTimeExtractor(args);
        // TODO Returns an exception in a method? Doesn't make sense
        // Returns a string? seems brittle, therefore to rewrite the class to preserve state
        try {
            // process StartEndDateTime first because it is more constrained
            dateTimeExtractor.processStartEndDateTime();
        } catch (PastDateTimeException e) {
            return new IncorrectCommand(e.getMessage());
        } catch (InvalidDurationException e) {
            return new IncorrectCommand(e.getMessage());
        } catch (IllegalValueException e) {
            // Dates can't be parsed so we silently skip first
            // all other exceptions have been handled
            // Pass rose from Uncle to Jane by tmr
            // we should not return an error because that case is a valid task
            System.out.println("No date is found for start and end date");
        }
        // TODO Returns an exception in a method? Doesn't make sense
        // Returns a string? seems brittle
        try {
            dateTimeExtractor.processDeadline();
        } catch (PastDateTimeException e) {
            return new IncorrectCommand(e.getMessage());
        } catch (IllegalValueException e) {
            // No date is found so we silently skip
            System.out.println("No date found for deadline!");
        }

        // TODO ArgumentTokenizer became very irrelevant in this class but is it still relevant for other classes?
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_TAG);
        argsTokenizer.tokenize(dateTimeExtractor.getProcessedArgs());
        try {
            String nameArgs = argsTokenizer.getPreamble().get();

            return new AddCommand(nameArgs, dateTimeExtractor.getProcessedDeadline(),
                    dateTimeExtractor.getProcessedStartEndDateTime(),
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG)));
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### /java/seedu/address/logic/parser/DateTimeExtractor.java
``` java
/**
 * Extracts Deadlines and StartEndDateTime if they exist
 *
 */
public class DateTimeExtractor {
    private final Logger logger = LogsCenter.getLogger(DateTimeExtractor.class);

    // TODO note that the below formats allow tags to be before from, to and by

    public static final Pattern HAS_STARTENDDATETIME_FORMAT = Pattern.compile(
            // match everything greedily so we can also include any number of [from] and [to]
            ".*"
            // match the final from with spaces to prevent matching words like therefrom and fromage
            + "(?<fromArg>\\sfrom\\s)"
            // now match greedily all the way until the next expression to match
            + "(?<startDateTime>.+)"
            // match a to with spaces to prevent matching words like auto and tomorrow
            + "\\sto\\s"
            // now match LAZILY as the next expression that follows is optional
            + "(?<endDateTime>.+?)"
            // match a white space character and a tag with zero or more times
            + "(?<tagArguments>(\\st/[^/]+)*)");
            // match a white space character with zero or one tag; // TODO change tag format
            // + "(?<tagArguments>(\\stags\\s[^/]+)?)");

    public static final Pattern HAS_DEADLINE_FORMAT = Pattern.compile(
            // match everything greedily so we can also include any number of [by]
            ".*"
            // match the final by with spaces to prevent matching words like baby and bypass
            + "(?<byArg>\\sby\\s)"
            // now match LAZILY as the next expression that follows is optional
            + "(?<deadline>.+?)"
            // match a white space character and a tag with zero or more times
            + "(?<tagArguments>(\\st/[^/]+)*)");
            // match a white space character with zero or one tag;
            // + "(?<tagArguments>(\\stags\\s[^/]+)?)"); // TODO change tag format

    public static final Pattern HAS_STARTDATETIME_FORMAT = Pattern.compile(
            // match everything greedily so we can also include any number of [from] and [to]
            ".*"
            // match the final from with spaces to prevent matching words like therefrom and fromage
            + "(?<fromArg>\\sfrom\\s)"
            // now match LAZILY as the next expression that follows is optional
            + "(?<startDateTime>.+?)"
            // match a white space character and a tag with zero or more times
            + "(?<tagArguments>(\\st/[^/]+)*)");
            // match a white space character with zero or one tag; // TODO change tag format
            // + "(?<tagArguments>(\\stags\\s[^/]+)?)");

    public static final Pattern HAS_ENDDATETIME_FORMAT = Pattern.compile(
            // match everything greedily so we can also include any number of [from] and [to]
            ".*"
            // match the final to with spaces to prevent matching words like auto and tomorrow
            + "(?<toArg>\\sto\\s)"
            // now match LAZILY as the next expression that follows is optional
            + "(?<endDateTime>.+?)"
            // match a white space character and a tag with zero or more times
            + "(?<tagArguments>(\\st/[^/]+)*)");
            // match a white space character with zero or one tag; // TODO change tag format
            // + "(?<tagArguments>(\\stags\\s[^/]+)?)");

    /**
     * Contains the argument string after processing
     */
    private String processedArgs;

    /**
     * Contains the Deadline after processing. Empty if does not exist
     */
    private Optional<Deadline> deadline;
    /**
     * Contains the Deadline as raw String after processing. Empty if does not exist
     */
    private Optional<String> rawDeadline;

    /**
     * Contains the startEndDateTime after processing. Empty if does not exist
     */
    private Optional<StartEndDateTime> startEndDateTime;
    /**
     * Contains the raw startDateTime after processing. Empty if does not exist
     */
    private Optional<String> rawStartDateTime;
    /**
     * Contains the raw endDateTime after processing. Empty if does not exist
     */
    private Optional<String> rawEndDateTime;

    public DateTimeExtractor(String args) {
        processedArgs = args;
    }

    public void processDeadline() throws PastDateTimeException, IllegalValueException {
        // perhaps include the raw as well
        deadline = Optional.empty();
        // only try to look for deadline if there is no start end date time
        if (getProcessedStartEndDateTime() == null || !getProcessedStartEndDateTime().isPresent()) {
            // Pass rose from Uncle to Jane by tmr
            Matcher matcher = HAS_DEADLINE_FORMAT.matcher(processedArgs);

            if (matcher.matches()) {
                final String matchedRawDeadline = matcher.group("deadline");
                ZonedDateTime dateTime = ParserUtil.parseDateTimeString(matchedRawDeadline);

                deadline = Optional.of(new Deadline(dateTime));
                processedArgs = new StringBuilder(processedArgs)
                        .replace(matcher.start("byArg"), matcher.end("deadline"), "")
                        .toString();
                // there will be extra whitespaces after extracting out the start and end date
                // e.g. project by Friday t/urgent => project  t/urgent
                // so we will normalize the whitespace
                processedArgs = StringUtils.normalizeSpace(processedArgs);

            } else {
                logger.info("----------------[PROCESS DEADLINE][No deadline found]");
            }
        }
    }

    /**
     * TODO Does not throw PastDateTimeException
     * @throws IllegalValueException
     */
    public void processRawDeadline() throws IllegalValueException {
        // TODO reduce duplication
        rawDeadline = Optional.empty();
        // deadline = Optional.empty(); deadline not to be initialized
        // only try to look for deadline if there is no start end date time
        // TODO temporarily ignore checks
        //if (getProcessedStartEndDateTime() == null || !getProcessedStartEndDateTime().isPresent()) {
        // Pass rose from Uncle to Jane by tmr
        Matcher matcher = HAS_DEADLINE_FORMAT.matcher(processedArgs);

        if (matcher.matches()) {
            final String matchedRawDeadline = matcher.group("deadline");
            if (!ParserUtil.isDateTimeString(matchedRawDeadline)) {
                return;
            }

            rawDeadline = Optional.of(matchedRawDeadline);
            // TODO whether the comment about past date time still need to be kept
            // since we don't actually know the date or time we don't know if it is past date yet
            // so no need to construct Deadline or check if it is past date
            // NO new Deadline();

            // assuming that rawDeadline will result into not a past date time
            // but past date times don't pass through anyway later on even with this "wrong" processedArgs
            // because exceptions will be thrown later
            processedArgs = new StringBuilder(processedArgs)
                    .replace(matcher.start("byArg"), matcher.end("deadline"), "")
                    .toString();
            // there will be extra whitespaces after extracting out the start and end date
            // e.g. project by Friday t/urgent => project  t/urgent
            // so we will normalize the whitespace
            processedArgs = StringUtils.normalizeSpace(processedArgs);

        } else {
            logger.info("----------------[PROCESS DEADLINE][No deadline found]");
        }
        //}

    }

    public void processStartEndDateTime()
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {
        // perhaps include the raw as well
        startEndDateTime = Optional.empty();

        // TODO add this
        //if (getProcessedDeadline() == null || !getProcessedDeadline().isPresent()) {
        Matcher matcher = HAS_STARTENDDATETIME_FORMAT.matcher(processedArgs);

        if (matcher.matches()) {
            logger.info("----------------[PROCESS STARTENDDATETIME][Start:"
                    + matcher.group("startDateTime") + "]");
            logger.info("----------------[PROCESS STARTENDDATETIME][End: "
                    + matcher.group("endDateTime") + "]");

            ZonedDateTime startDateTime =
                    ParserUtil.parseDateTimeString(matcher.group("startDateTime"));
            ZonedDateTime endDateTime =
                    ParserUtil.parseDateTimeString(matcher.group("endDateTime"));

            startEndDateTime = Optional.of(new StartEndDateTime(startDateTime, endDateTime));
            processedArgs =
                    new StringBuilder(processedArgs).replace(matcher.start("fromArg"),
                            matcher.end("endDateTime"), "").toString();
            // there will be extra whitespaces after extracting out the start and end date
            // e.g. meeting from Wednesday to Thursday t/tag => meeting from t/tag
            // so we will normalize the whitespace
            processedArgs = StringUtils.normalizeSpace(processedArgs);
        } else {
            logger.info("----------------[PROCESS STARTENDDATETIME][No Start and End Date Time found]");
        }
    }

    /**
     * TODO Does not throw PastDateTimeException and InvalidDurationException
     * @throws IllegalValueException
     */
    public void processRawStartEndDateTime() throws IllegalValueException {
        rawStartDateTime = Optional.empty();
        rawEndDateTime = Optional.empty();

        // TODO add this
        //if (getProcessedDeadline() == null || !getProcessedDeadline().isPresent()) {
        Matcher matcher = HAS_STARTENDDATETIME_FORMAT.matcher(processedArgs);

        if (matcher.matches()) {
            final String matchedStartDateTime = matcher.group("startDateTime");
            final String matchedEndDateTime = matcher.group("endDateTime");
            logger.info("----------------[PROCESS RAWSTARTENDDATETIME][Start:"
                    + matchedStartDateTime + "]");
            logger.info("----------------[PROCESS RAWSTARTENDDATETIME][End: "
                    + matchedEndDateTime + "]");
            if (!ParserUtil.isDateTimeString(matchedStartDateTime)
                    || !ParserUtil.isDateTimeString(matchedEndDateTime)) {
                return;
            }
            rawStartDateTime = Optional.of(matchedStartDateTime);
            rawEndDateTime = Optional.of(matchedEndDateTime);
            // TODO whether the comment about past date time still need to be kept
            // since we don't actually know the date or time we don't know if it is past date yet
            // so no need to construct StartEndDateTime or check if it is past date
            // no InvalidDurationException as well
            // NO new StartEndDateTime();

            // assuming that rawStart and end will result into not a past date time and invaliddurationexception
            // but past date times don't pass through anyway later on even with this "wrong" processedArgs
            // because exceptions will be thrown later
            processedArgs =
                    new StringBuilder(processedArgs).replace(matcher.start("fromArg"),
                            matcher.end("endDateTime"), "").toString();
            // there will be extra whitespaces after extracting out the start and end date
            // e.g. meeting from Wednesday to Thursday t/tag => meeting from t/tag
            // so we will normalize the whitespace
            processedArgs = StringUtils.normalizeSpace(processedArgs);
        } else {
            logger.info("----------------[PROCESS RAWSTARTENDDATETIME][No Start and End Date Time found]");
        }
    }
    // TODO processRawStartDateTime and processRawEndDateTime only for special case for EditCommandParser

    public void processRawStartDateTime() throws IllegalValueException {
        // TODO only initialize if haven't initialized
        if (rawStartDateTime == null) {
            rawStartDateTime = Optional.empty();
        }

        // TODO add this
        //if (getProcessedDeadline() == null || !getProcessedDeadline().isPresent()) {
        Matcher matcher = HAS_STARTDATETIME_FORMAT.matcher(processedArgs);

        if (matcher.matches()) {
            final String matchedStartDateTime = matcher.group("startDateTime");
            logger.info("----------------[PROCESS RAWSTARTDATETIME][Start:"
                    + matchedStartDateTime + "]");
            if (!ParserUtil.isDateTimeString(matchedStartDateTime)) {
                return;
            }
            rawStartDateTime = Optional.of(matchedStartDateTime);
            // TODO whether the comment about past date time still need to be kept
            // since we don't actually know the date or time we don't know if it is past date yet
            // so no need to construct StartEndDateTime or check if it is past date
            // no InvalidDurationException as well
            // NO new StartEndDateTime();

            // assuming that rawStart and end will result into not a past date time and invaliddurationexception
            // but past date times don't pass through anyway later on even with this "wrong" processedArgs
            // because exceptions will be thrown later
            processedArgs =
                    new StringBuilder(processedArgs).replace(matcher.start("fromArg"),
                            matcher.end("startDateTime"), "").toString();
            // there will be extra whitespaces after extracting out the start and end date
            // e.g. meeting from Wednesday to Thursday t/tag => meeting from t/tag
            // so we will normalize the whitespace
            processedArgs = StringUtils.normalizeSpace(processedArgs);
        } else {
            logger.info("----------------[PROCESS RAWSTARTDATETIME][No Start Time found]");
        }
    }

    public void processRawEndDateTime() throws IllegalValueException {
        // TODO only initialize if haven't initialized
        if (rawEndDateTime == null) {
            rawEndDateTime = Optional.empty();
        }

        // TODO add this
        //if (getProcessedDeadline() == null || !getProcessedDeadline().isPresent()) {
        Matcher matcher = HAS_ENDDATETIME_FORMAT.matcher(processedArgs);

        if (matcher.matches()) {
            final String matchedEndDateTime = matcher.group("endDateTime");
            logger.info("----------------[PROCESS RAWENDDATETIME][End:"
                    + matchedEndDateTime + "]");
            if (!ParserUtil.isDateTimeString(matchedEndDateTime)) {
                return;
            }
            rawEndDateTime = Optional.of(matchedEndDateTime);
            // TODO whether the comment about past date time still need to be kept
            // since we don't actually know the date or time we don't know if it is past date yet
            // so no need to construct StartEndDateTime or check if it is past date
            // no InvalidDurationException as well
            // NO new StartEndDateTime();

            // assuming that rawStart and end will result into not a past date time and invaliddurationexception
            // but past date times don't pass through anyway later on even with this "wrong" processedArgs
            // because exceptions will be thrown later
            processedArgs =
                    new StringBuilder(processedArgs).replace(matcher.start("toArg"),
                            matcher.end("endDateTime"), "").toString();
            // there will be extra whitespaces after extracting out the start and end date
            // e.g. meeting from Wednesday to Thursday t/tag => meeting from t/tag
            // so we will normalize the whitespace
            processedArgs = StringUtils.normalizeSpace(processedArgs);
        } else {
            logger.info("----------------[PROCESS RAWENDDATETIME][No Start Time found]");
        }

    }

    /**
     * Returns the argument after processing
     */
    public String getProcessedArgs() {
        return processedArgs;
    }

    /**
     * Returns the processed deadline if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<Deadline> getProcessedDeadline() {
        return deadline;
    }

    /**
     * Returns the raw deadline if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedRawDeadline() {
        return rawDeadline;
    }

    /**
     * Returns the processed startEndDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<StartEndDateTime> getProcessedStartEndDateTime() {
        return startEndDateTime;
    }

    /**
     * Returns the processed startDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedStartDateTime() {
        return rawStartDateTime;
    }

    /**
     * Returns the processed endDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedEndDateTime() {
        return rawEndDateTime;
    }
}
```
###### /java/seedu/address/logic/parser/EditCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        // TODO use the new dateTimeExtractor class
        DateTimeExtractor dateTimeExtractor = new DateTimeExtractor(args);
        // TODO Returns an exception in a method? Doesn't make sense
        // Returns a string? seems brittle, therefore to rewrite the class to preserve state
        try {
            // process StartEndDateTime first because it is more constrained
            // TODO there are special from and to cases so maybe we don't have to necessarily process
            // this first. create a special optional regex for this?
            //dateTimeExtractor.processStartEndDateTime();
            dateTimeExtractor.processRawStartEndDateTime();
        } catch (IllegalValueException e) {
            // Dates can't be parsed so we silently skip first
            // all other exceptions have been handled
            // Pass rose from Uncle to Jane by tmr
            // we should not return an error because that case is a valid task
            System.out.println("No date is found for start and end date");
        }
        // TODO Returns an exception in a method? Doesn't make sense
        // Returns a string? seems brittle
        try {
            dateTimeExtractor.processRawDeadline();
        } catch (IllegalValueException e) {
            // No date is found so we silently skip
            System.out.println("No date found for deadline!");
        }
        // TODO process from later
        // because for example edit 10 test by 2 days from 25 Apr
        // note again that edit 10 test by 2 days later from 25 Apr will ignore the from later
        try {
            dateTimeExtractor.processRawStartDateTime();
        } catch (IllegalValueException e) {
            // No date is found so we silently skip
            System.out.println("No date found for start date only!");
        }
        // TODO process to later because it is even shorter
        try {
            dateTimeExtractor.processRawEndDateTime();
        } catch (IllegalValueException e) {
            // No date is found so we silently skip
            System.out.println("No date found for start date only!");
        }

        // TODO ArgumentTokenizer became very irrelevant in this class but is it still relevant for other classes?
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_TAG);
        argsTokenizer.tokenize(dateTimeExtractor.getProcessedArgs());
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        try {
            editTaskDescriptor.setName(ParserUtil.parseName(preambleFields.get(1)));

            editTaskDescriptor.setRawDeadline(dateTimeExtractor.getProcessedRawDeadline());
            editTaskDescriptor.setRawStartDateTime(dateTimeExtractor.getProcessedStartDateTime());
            editTaskDescriptor.setRawEndDateTime(dateTimeExtractor.getProcessedEndDateTime());


            //editTaskDescriptor.setDeadline(
            //        ParserUtil.parseDeadline(argsTokenizer.getValue(PREFIX_DEADLINE_DATETIME)));
            //editTaskDescriptor.setStartEndDateTime(
            //        ParserUtil.parseStartEndDateTime(argsTokenizer.getValue(PREFIX_START_DATETIME),
            //                                         argsTokenizer.getValue(PREFIX_END_DATETIME)));
            editTaskDescriptor.setTagList(parseTagsForEdit(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        return new EditCommand(index.get(), editTaskDescriptor);
        // TODO note that there is a NoFieldEditedException handled in execute, thus to change
    }

```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
    private static Parser dateTimeParser = new Parser(TimeZone.getDefault()); // TODO timezones
    // TODO decide if this is the right class
    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ISO_DATE_TIME;

```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
    /**
     * TODO comments. For new deadlines
     * @param deadline
     * @return
     * @throws PastDateTimeException
     * @throws IllegalValueException
     */
    public static Optional<Deadline> parseNewDeadline(Optional<String> deadline)
            throws PastDateTimeException, IllegalValueException {
        assert deadline != null;
        return deadline.isPresent() ? Optional.of(new Deadline(parseDateTimeString(deadline.get()))) : Optional.empty();
    }

    /**
     * TODO Comments. For Edited deadlines
     * @param rawDeadline
     * @param previousDeadline
     * @return
     * @throws PastDateTimeException
     * @throws IllegalValueException
     */
    public static Optional<Deadline> parseEditedDeadline(Optional<String> rawDeadline, Deadline previousDeadline)
            throws PastDateTimeException, IllegalValueException {
        assert rawDeadline != null;
        if (rawDeadline.isPresent()) {
            return Optional.of(new Deadline(parseEditedDateTimeString(rawDeadline.get(), previousDeadline.getValue())));
        } else {
            return Optional.empty();
        }
    }

    public static Optional<StartEndDateTime> parseEditedStartEndDateTime(Optional<String> startDateTime,
            Optional<String> endDateTime, StartEndDateTime previousStartEndDateTime)
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {
        assert startDateTime != null && endDateTime != null;

        if (!startDateTime.isPresent() || !endDateTime.isPresent()) {
            // TODO If it is malformed should we just ignore or should we do further checks and throw an error?
            return Optional.empty();
        }

        StartEndDateTime startEndDateTime = new StartEndDateTime(
                parseEditedDateTimeString(startDateTime.get(), previousStartEndDateTime.getStartDateTime()),
                parseEditedDateTimeString(endDateTime.get(), previousStartEndDateTime.getEndDateTime()));

        return Optional.of(startEndDateTime);
    }

    public static Optional<StartEndDateTime> parseNewStartEndDateTime(Optional<String> startDateTime,
            Optional<String> endDateTime)
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {
        assert startDateTime != null && endDateTime != null;

        if (!startDateTime.isPresent() || !endDateTime.isPresent()) {
            // TODO If it is malformed should we just ignore or should we do further checks and throw an error?
            return Optional.empty();
        }

        StartEndDateTime startEndDateTime = new StartEndDateTime(parseDateTimeString(startDateTime.get()),
                                                                 parseDateTimeString(endDateTime.get()));

        return Optional.of(startEndDateTime);
    }

    public static ZonedDateTime parseEditedDateTimeString(String dateTime, ZonedDateTime previousDate)
            throws IllegalValueException {
        // TODO extract commonalities from parseDateTimeString
        // TODO check if only one group and only one date from list (date alternatives)
        List<DateGroup> groups = dateTimeParser.parse(dateTime);
        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            if (dates.size() > 0) {
                // 24 hours later what happens
                System.out.println("Date inferred: " + group.isDateInferred());
                System.out.println("Time inferred: " + group.isTimeInferred());
                System.out.println("Date type: " + group.getSyntaxTree().getChild(0).getChild(0));
                String dateType = group.getSyntaxTree().getChild(0).getChild(0).getText();
                if (dateType.equals("RELATIVE_DATE") || dateType.equals("RELATIVE_TIME")) {
                    // such as 24 hours later
                    // such as 2 days later
                    // Relative dates should always be relative to current date not other dates
                    // special cases such as 2 days after 25 Apr also works
                    // but cases such as 2 hours after 25 Apr 8pm does not work
                    // Neither does cases such as 2 hours after 25 Apr 8pm work
                    System.out.println("Relative do nothing!");
                } else {
                    if (group.isDateInferred()) {
                        System.out.println("Date inferred");
                        // TODO do timezones properly
                        // note Natty does not support SGT so we use offset but this means timezone info
                        // such as daylight saving time adjustments are lost
                        String extractedDate = new SimpleDateFormat("HH:mm:ss Z").format(dates.get(0));
                        //System.out.println(new SimpleDateFormat("HH:mm:ss z").format(dates.get(0)));
                        //System.out.println(new SimpleDateFormat("HH:mm:ss Z").format(dates.get(0)));
                        //System.out.println(new SimpleDateFormat("HH:mm:ss zz").format(dates.get(0)));
                        List<DateGroup> groupsRedone =
                                dateTimeParser.parse(extractedDate, Date.from(previousDate.toInstant()));
                        Date newDate = groupsRedone.get(0).getDates().get(0);
                        return ZonedDateTime.ofInstant(newDate.toInstant(), ZoneId.systemDefault());
                    }
                    if (group.isTimeInferred()) {
                        System.out.println("Time inferred");
                        // TODO using SimpleDateFormat cos old date
                        String extractedDate = new SimpleDateFormat("yyyy-MM-dd").format(dates.get(0));
                        List<DateGroup> groupsRedone =
                                dateTimeParser.parse(extractedDate, Date.from(previousDate.toInstant()));
                        Date newDate = groupsRedone.get(0).getDates().get(0);
                        return ZonedDateTime.ofInstant(newDate.toInstant(), ZoneId.systemDefault());
                    }
                }
                // TODO comment Avoid old Date class where possible format
                Instant instant = dates.get(0).toInstant();
                ZoneId zoneId = ZoneId.systemDefault();

                // TODO use a ZonedDateTime so user can see time in his timezone, perhaps
                // Instant can be used where possible and only when reading input and output from user
                // we use ZonedDateTime
                ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, zoneId);
                return zonedDateTime;
            }
        }
        throw new IllegalValueException(dateTime + " is not a valid date/time.");
    }

    // TODO notice the inconsistencies of the parsing class, maybe need to change this
    /**
     * Parses Date strings into a {@code ZonedDateTime}.
     */
    public static ZonedDateTime parseDateTimeString(String dateTime) throws IllegalValueException {
        List<DateGroup> groups = dateTimeParser.parse(dateTime);
        // TODO check if only one group and only one date from list (date alternatives)
        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            if (dates.size() > 0) {
                // TODO comment Avoid old Date class where possible format
                Instant instant = dates.get(0).toInstant();
                ZoneId zoneId = ZoneId.systemDefault();

                // TODO use a ZonedDateTime so user can see time in his timezone, perhaps
                // Instant can be used where possible and only when reading input and output from user
                // we use ZonedDateTime
                ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, zoneId);
                return zonedDateTime;
            }
        }
        throw new IllegalValueException(dateTime + " is not a valid date/time.");
    }

    // TODO maybe doesn't belong in ParserUtil
    /**
     * Returns if Date strings are valid DateTimes.
     */
    public static boolean isDateTimeString(String dateTime) throws IllegalValueException {
        List<DateGroup> groups = dateTimeParser.parse(dateTime);
        // TODO check if only one group and only one date from list (date alternatives)
        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            if (dates.size() > 0) {
                // TODO note that the size should be == 1 because it shouldn't be more than one date
                return true;
            }
        }
        return false;
    }
}
```
###### /java/seedu/address/model/task/Deadline.java
``` java
public class Deadline {
    public static final String MESSAGE_DEADLINE_CONSTRAINTS = "Deadline should not be in the past";

    private ZonedDateTime dateTime;

    /**
     * Constructs a new Deadline with the given DateTime.
     *
     * @param dateTime the DateTime to specify for the deadline
     * @throws PastDateTimeException if {@code dateTime} is before the current DateTime
     */
    public Deadline(ZonedDateTime dateTime) throws PastDateTimeException {
        this(dateTime, false);
    }

    /**
     * Constructs a new Deadline with the given DateTime. Ignores checking for dates in the past if
     * {@code ignorePast} is true.
     *
     * @param dateTime the DateTime to specify for the deadline
     * @param allowPastDateTime ignore checking if {@code dateTime} is in the past. Avoid setting
     *        to true except for cases such as loading from storage
     * @throws PastDateTimeException if {@code dateTime} is before the current DateTime and
     *         {@code allowPastDateTime} is {@code false}
     */
    public Deadline(ZonedDateTime dateTime, boolean allowPastDateTime) throws PastDateTimeException {
        assert dateTime != null;

        // TODO
        if (!allowPastDateTime) {
            if (dateTime.isBefore(ZonedDateTime.now())) {
                throw new PastDateTimeException(MESSAGE_DEADLINE_CONSTRAINTS);
            }
        }

        this.dateTime = dateTime;
    }

    public ZonedDateTime getValue() {
        return dateTime;
    }

    @Override
    public String toString() {
        return dateTime.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final Deadline other = (Deadline) o;

        return Objects.equals(getValue(), other.getValue());
    }

    @Override
    public int hashCode() {
        return dateTime.hashCode();
    }
}
```
###### /java/seedu/address/model/task/exceptions/IllegalDateTimeException.java
``` java
/**
 * Signals that some given DateTime(s) does not fulfill some date related constraints.
 */
public abstract class IllegalDateTimeException extends Exception {

    /**
     * @param message should contain relevant information on the failed date related constraint(s)
     */
    public IllegalDateTimeException(String message) {
        super(message);
    }

}
```
###### /java/seedu/address/model/task/exceptions/InvalidDurationException.java
``` java
/**
 * Signals that the duration between two dates are negative or zero, thus constituting an invalid duration.
 */
public class InvalidDurationException extends IllegalDateTimeException {

    /**
     * @param message should contain relevant information on how the two dates have an
     *        invalid duration between them
     */
    public InvalidDurationException(String message) {
        super(message);
    }

}
```
###### /java/seedu/address/model/task/exceptions/PastDateTimeException.java
``` java
/**
 * Signals that a date constructed was in the past.
 */
public class PastDateTimeException extends IllegalDateTimeException {

    /**
     * @param message should contain relevant information on why the date should not be in the past.
     */
    public PastDateTimeException(String message) {
        super(message);
    }

}
```
###### /java/seedu/address/model/task/ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final ReadOnlyTask other = (ReadOnlyTask) o;

        return Objects.equals(getName(), other.getName())
                && Objects.equals(getDeadline(), other.getDeadline())
                && Objects.equals(getStartEndDateTime(), other.getStartEndDateTime());
        // TODO tags should actually be checked because that's how equals should usually function
        // However, the equals here is used to check for duplicates and is not really consistent
        // with how equals behave. Thus to further investigate.
        // Furthermore, this current implementation does not allow Tasks with same name to go through
        // if there are no deadlines or start and end date time. Probably would be better to remove
        // the duplicate task exception in this case.
    }

    /**
     * Formats the task as text, showing all fields.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        buildNameString(builder);
        buildDeadlineString(builder);
        buildStartEndDateTimeString(builder);
        buildTagsString(builder);

        return builder.toString();
    }

    default void buildNameString(final StringBuilder builder) {
        builder.append(getName());
    }

    default void buildDeadlineString(final StringBuilder builder) {
        // TODO don't include milliseconds in toString output
        builder.append(" Deadline: ");
        builder.append(getDeadline().isPresent() ? getDeadline().get().toString() : "none");
    }

    default void buildStartEndDateTimeString(final StringBuilder builder) {
        // TODO don't include milliseconds in toString output
        if (getStartEndDateTime().isPresent()) {
            builder.append(" ");
            builder.append(getStartEndDateTime().get().toString());
        } else {
            builder.append(" Start Date: none ");
            builder.append(" End Date: none ");
        }
    }

    default void buildTagsString(final StringBuilder builder) {
        builder.append(" Tags: ");
        getTags().forEach(builder::append);
    }

}
```
###### /java/seedu/address/model/task/StartEndDateTime.java
``` java
public class StartEndDateTime {
    public static final String MESSAGE_STARTDATETIME_CONSTRAINTS = "Start Date/Time should not be in the past";
    public static final String MESSAGE_ENDDATETIME_CONSTRAINTS = "End Date/Time should not be in the past";
    public static final String MESSAGE_STARTENDDATETIME_CONSTRAINTS = "End Date/Time must be after Start Date/Time";

    private ZonedDateTime startDateTime;
    private ZonedDateTime endDateTime;

    /**
     * Constructs a new StartDateTime with the given start and end DateTime.
     *
     * @param startDateTime the start DateTime
     * @param endDateTime the end DateTime
     * @throws PastDateTimeException if any of the DateTimes are before the current DateTime
     * @throws InvalidDurationException if the end DateTime is before or same as the start DateTime
     */
    public StartEndDateTime(ZonedDateTime startDateTime, ZonedDateTime endDateTime)
            throws PastDateTimeException, InvalidDurationException {
        this(startDateTime, endDateTime, false);
    }

    /**
     * Constructs a new StartEndDateTime with the given start and end DateTime. Ignores checking for
     * dates in the past if {@code ignorePast} is true.
     *
     * @param startDateTime the start DateTime
     * @param endDateTime the end DateTime
     * @param allowPastDateTime ignore checking if DateTimes are in the past. Avoid setting to true
     *        except for special cases such as loading from storage
     * @throws PastDateTimeException if any of the DateTimes are before the current DateTime and
     *         {@code allowPastDateTime} is {@code false}
     * @throws InvalidDurationException if the end DateTime is before or same as the start DateTime
     */
    public StartEndDateTime(ZonedDateTime startDateTime, ZonedDateTime endDateTime, boolean allowPastDateTime)
            throws PastDateTimeException, InvalidDurationException {
        assert startDateTime != null && endDateTime != null;

        if (!allowPastDateTime) {
            // fix the current date time otherwise testing startDateTime might pass but
            // testing endDateTime might fail because the current DateTime might have passed endDateTime
            ZonedDateTime currentDateTime = ZonedDateTime.now();
            if (startDateTime.isBefore(currentDateTime)) {
                throw new PastDateTimeException(MESSAGE_STARTDATETIME_CONSTRAINTS);
            }

            if (endDateTime.isBefore(currentDateTime)) {
                throw new PastDateTimeException(MESSAGE_ENDDATETIME_CONSTRAINTS);
            }
        }

        // The end date time must be after the start date time, but not same or before
        if (!endDateTime.isAfter(startDateTime)) {
            throw new InvalidDurationException(MESSAGE_STARTENDDATETIME_CONSTRAINTS);
        }

        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
    }

    public ZonedDateTime getStartDateTime() {
        return startDateTime;
    }

    public ZonedDateTime getEndDateTime() {
        return endDateTime;
    }

    @Override
    public String toString() {
        return "Start Date: " + startDateTime.toString() + " End Date: " + endDateTime.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final StartEndDateTime other = (StartEndDateTime) o;

        return Objects.equals(getStartDateTime(), other.getStartDateTime())
                && Objects.equals(getEndDateTime(), other.getEndDateTime());
    }

    @Override
    public int hashCode() {
        return Objects.hash(startDateTime, endDateTime);
    }

}
```
###### /java/seedu/address/model/task/Task.java
``` java
    @Override
    public Optional<Deadline> getDeadline() {
        return deadline;
    }

    /**
     * Only allow changing the {@link StartEndDateTime} if there is actually a value (not {@link Optional}).
     */
    public void setDeadline(Deadline dateTime) {
        assert dateTime != null;
        this.deadline = Optional.of(dateTime);
    }

    @Override
    public Optional<StartEndDateTime> getStartEndDateTime() {
        return startEndDateTime;
    }

    /**
     * Only allow changing the {@link StartEndDateTime} if there is actually a value (not {@link Optional}).
     */
    public void setStartEndDateTime(StartEndDateTime startEndDateTime) {
        assert startEndDateTime != null;
        this.startEndDateTime = Optional.of(startEndDateTime);
    }

```
###### /java/seedu/address/model/task/Task.java
``` java
    /**
     * Updates this task with the details of {@code replacement} using a "shallow copy" of the data. Refer to
     * {@link Object#clone()} for more information about shallow copy.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        // Note that we are shallow copying data replacement's data so replacement should not be
        // reused anymore. Otherwise modify this method to do a deep copy

        setName(replacement.getName());

        // Note that we are reusing the same Optional from replacement directly
        // Hence we are not using the setter method which only accepts Deadline
        deadline = replacement.getDeadline();
        // Similarly for startEndDateTime we are reusing same Optional
        startEndDateTime = replacement.getStartEndDateTime();

        setTags(replacement.getTags());
    }

```
###### /java/seedu/address/model/util/SampleDataUtil.java
``` java
    public static Task[] getSampleTasks() {
        try {
            // TODO improve variety of test cases
            return new Task[] {
                new Task(new Name("EE2021"), Optional.of(new Deadline(ZonedDateTime.now().plusDays(3))),
                         Optional.empty(), new UniqueTagList("homework")),
                new Task(new Name("MA1506"), Optional.empty(), Optional.empty(),
                         new UniqueTagList("killer", "revision")),
                new Task(new Name("CS2103 Project"), Optional.empty(), Optional.empty(), new UniqueTagList("Help")),
                new Task(new Name("PC1222 Lecture"), Optional.empty(), Optional.empty(), new UniqueTagList("lecture")),
                new Task(new Name("GEH1027 Lecture"), Optional.empty(), Optional.empty(), new UniqueTagList("lecture")),
                new Task(new Name("HOHO Time"), Optional.empty(), Optional.empty(), new UniqueTagList("LMAO"))
            };
        } catch (PastDateTimeException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }

```
###### /java/seedu/address/storage/XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(name = "name", required = true)
    private String nameElement;

    @XmlElement(name = "deadline")
    private String deadlineElement;

    @XmlElement(name = "startDate")
    private String startDateTimeElement;

    @XmlElement(name = "endDate")
    private String endDateTimeElement;

    @XmlElement(name = "tag")
    private List<XmlAdaptedTag> tagElements = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        setNameElement(source.getName().value);

        setDeadlineElementIfPresent(source.getDeadline());
        // the start and end date elements must be set together because they cannot exist separately
        setStartEndDateElementsIfPresent(source.getStartEndDateTime());

        // TODO do I need to check if Deadline exists then StartEndDateTime cannot exists and vice versa

        setTagElement(source.getTags());
    }

    /**
     * Sets the XmlElement name to the source task's name
     */
    private void setNameElement(String sourceName) {
        nameElement = sourceName;
    }

    /**
     * Sets the XmlElement name to the source task's deadline if it is present
     */
    private void setDeadlineElementIfPresent(Optional<Deadline> sourceDeadline) {
        if (sourceDeadline.isPresent()) {
            Deadline deadline = sourceDeadline.get();
            deadlineElement = deadline.getValue().format(ParserUtil.DATE_TIME_FORMAT);
        }
    }

    /**
     * Sets the XmlElement startDate and endDate to the source task's start and dates if they are present
     */
    private void setStartEndDateElementsIfPresent(Optional<StartEndDateTime> sourceStartEndDateTime) {
        if (sourceStartEndDateTime.isPresent()) {
            StartEndDateTime startEndDateTime = sourceStartEndDateTime.get();
            startDateTimeElement = startEndDateTime.getStartDateTime().format(ParserUtil.DATE_TIME_FORMAT);
            endDateTimeElement = startEndDateTime.getEndDateTime().format(ParserUtil.DATE_TIME_FORMAT);
        }
    }

    /**
     * Sets each tag XmlElement to the source task's tags from its unique tag list
     */
    private void setTagElement(UniqueTagList sourceTagList) {
        tagElements = new ArrayList<>();
        for (Tag tag : sourceTagList) {
            tagElements.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     * @throws InvalidDurationException if the end DateTime is before or same as the start DateTime
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException, PastDateTimeException, InvalidDurationException {
        // TODO get seems to not be a good name, as it is usually used for getters
        final Name name = getNameFromXmlElement();
        final Optional<Deadline> deadline = getDeadlineFromXmlElement();
        final Optional<StartEndDateTime> startEndDateTime = getStartEndDateTimeFromXmlElement();
        final UniqueTagList tagList = getTagListFromXmlElement();

        return new Task(name, deadline, startEndDateTime, tagList);
    }

    /**
     * Returns a Name created from the XmlElement.
     * @throws IllegalValueException if the name does not fulfill the name's constraints
     */
    private Name getNameFromXmlElement() throws IllegalValueException {
        return new Name(nameElement);
    }

    /**
     * Returns an {@link Optional} wrapping the {@link Deadline} created from the XmlElement.
     * If the XmlElement for deadline does not exist, returns an empty {@link Optional}.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     */
    private Optional<Deadline> getDeadlineFromXmlElement() throws PastDateTimeException {
        // return empty if xml element does not exist
        if (deadlineElement == null) {
            return Optional.empty();
        }
        // construct Deadline with allowPastDateTime set to true because this is loaded from storage
        Deadline deadline = new Deadline(ZonedDateTime.parse(deadlineElement, ParserUtil.DATE_TIME_FORMAT), true);
        return Optional.of(deadline);
    }

    /**
     * Returns an {@link Optional} wrapping the {@link StartEndDateTime} created from the two XmlElements.
     * If any of the two XmlElements for StartEndDateTime does not exist, returns an empty {@link Optional}.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     * @throws InvalidDurationException if the end DateTime is before or same as the start DateTime
     */
    private Optional<StartEndDateTime> getStartEndDateTimeFromXmlElement()
            throws PastDateTimeException, InvalidDurationException {
        // return empty if either xml element does not exist
        if (startDateTimeElement == null || endDateTimeElement == null) {
            return Optional.empty();
        }
        ZonedDateTime startDateTime = ZonedDateTime.parse(startDateTimeElement, ParserUtil.DATE_TIME_FORMAT);
        ZonedDateTime endDateTime = ZonedDateTime.parse(endDateTimeElement, ParserUtil.DATE_TIME_FORMAT);
        // construct StartEndDateTime with allowPastDateTime set to true because this is loaded from storage
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime, true);
        return Optional.of(startEndDateTime);
    }

    /**
     * Returns a UniqueTagList of the tags created from every tag XmlElement for the Task
     * @throws IllegalValueException if any of the tags from the XML is invalid
     * @throws DuplicateTagException if any of the tags are duplicates
     */
    private UniqueTagList getTagListFromXmlElement() throws IllegalValueException, DuplicateTagException {
        final List<Tag> tags = new ArrayList<>();
        for (XmlAdaptedTag adaptedTag : tagElements) {
            tags.add(adaptedTag.toModelType());
        }
        return new UniqueTagList(tags);
    }
}
```
###### /java/seedu/address/storage/XmlSerializableTaskList.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        final ObservableList<Task> tasks = this.tasks.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (PastDateTimeException e) {
                // this should never happen as we loaded from storage
                // TODO should we handle this differently or earlier?
                return null;
            } catch (InvalidDurationException e) {
                // TODO should we handle this earlier?
                return null;
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(tasks);
    }

```
