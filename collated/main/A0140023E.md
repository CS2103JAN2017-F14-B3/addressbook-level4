# A0140023E
###### /java/seedu/address/commons/util/StringUtil.java
``` java
    /**
     * Returns {@code s} with substring of {@code s} specified by {@code startIndex} and {@code endIndex}
     * replaced with the substring {@code replacement}. The substring begins at the
     * specified {@code startIndex} and ends at {@code endIndex} - 1 or to the
     * end of the s if {@code endIndex} is larger than length of s. First the characters in the substring
     * are removed and then the specified String is inserted at {@code startIndex}. (The String will be
     * lengthened to accommodate the specified String if necessary.)
     *
     * @param s the String that contains the substring to be replaced specified by {@code startIndex} and
     *        {@code endIndex}
     * @param startIndex The beginning index, inclusive.
     * @param endIndex The ending index, exclusive.
     * @param replacement the substring to replace
     * @return s with substring replaced
     * @see StringBuilder#replace(int, int, String)
     */
    public static String replace(String s, int startIndex, int endIndex, String replacement) {
        assert s != null && replacement != null;

        StringBuilder sb = new StringBuilder(s);
        sb.replace(startIndex, endIndex, replacement);
        return sb.toString();
    }
}
```
###### /java/seedu/address/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values except {@code deadline} and {@code startEndDateTime}
     * that must be pre-initialized.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String nameArgs, Optional<Deadline> deadline,
            Optional<StartEndDateTime> startEndDateTime, Set<String> tags) throws IllegalValueException {
        toAdd = new Task(new Name(nameArgs), deadline, startEndDateTime, initTagList(tags));
    }

    /**
     * Returns initialized tags as a {@link UniqueTagList}
     * @throws IllegalValueException if there is a tag name that is invalid in the given tags set
     */
    private UniqueTagList initTagList(Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        return new UniqueTagList(tagSet);
    }

```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        try {
            editTaskDescriptor.processFields(taskToEdit);
        } catch (PastDateTimeException | InvalidDurationException | IllegalValueException e) {
            throw new CommandException(e.getMessage());
        }

        if (!this.editTaskDescriptor.isAnyFieldEdited(taskToEdit)) {
            throw new CommandException(EditCommand.MESSAGE_NOT_EDITED);
        }

        Task editedTask = new Task(editTaskDescriptor.getUpdatedName(),
                editTaskDescriptor.getUpdatedDeadline(),
                editTaskDescriptor.getUpdatedStartEndDateTime(),
                editTaskDescriptor.getUpdatedTagList());

        try {
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<String> rawDeadline = Optional.empty();
        private Optional<String> rawStartDateTime = Optional.empty();
        private Optional<String> rawEndDateTime = Optional.empty();
        private Optional<UniqueTagList> tagList = Optional.empty();

        private Name updatedName;
        private Optional<Deadline> updatedDeadline;
        private Optional<StartEndDateTime> updatedStartEndDateTime;
        private UniqueTagList updatedTagList;

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            name = toCopy.getName();
            rawDeadline = toCopy.getRawDeadline();
            rawStartDateTime = toCopy.getRawStartDateTime();
            rawEndDateTime = toCopy.getRawEndDateTime();
            tagList = toCopy.getTagList();

            updatedName = toCopy.getUpdatedName();
            updatedDeadline = toCopy.getUpdatedDeadline();
            updatedStartEndDateTime = toCopy.getUpdatedStartEndDateTime();
            updatedTagList = toCopy.getUpdatedTagList();
        }

        public void processFields(ReadOnlyTask taskToEdit)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            processName(taskToEdit);
            processDeadline(taskToEdit);
            processStartEndDateTime(taskToEdit);
            processTagList(taskToEdit);
        }

        private void processName(ReadOnlyTask taskToEdit) {
            updatedName = getName().orElseGet(taskToEdit::getName);
        }

        private void processDeadline(ReadOnlyTask taskToEdit)
                throws PastDateTimeException, IllegalValueException {
            if (!getRawDeadline().isPresent()) {
                updatedDeadline = taskToEdit.getDeadline();
                return;
            }

            if (taskToEdit.getDeadline().isPresent()) {
                updatedDeadline = ParserUtil.parseEditedDeadline(getRawDeadline(), taskToEdit.getDeadline().get());
            } else {
                updatedDeadline = ParserUtil.parseNewDeadline(getRawDeadline());
            }
        }

        private void processStartEndDateTime(ReadOnlyTask taskToEdit)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {
            updatedStartEndDateTime = Optional.empty();

            if (hasNoRawStartAndEndDateTime()) {
                updatedStartEndDateTime = taskToEdit.getStartEndDateTime();
                return;
            }

            if (!taskToEdit.getStartEndDateTime().isPresent()) {
                if (hasBothRawStartAndEndDateTime()) {
                    updatedStartEndDateTime =
                            ParserUtil.parseNewStartEndDateTime(getRawStartDateTime(), getRawEndDateTime());
                    return;
                }
                throw new IllegalValueException("Must have both start and end date-time");
            }

            final StartEndDateTime originalStartEndDateTime = taskToEdit.getStartEndDateTime().get();

            if (hasBothRawStartAndEndDateTime()) {
                processUsingRawStartAndEnd(originalStartEndDateTime);
            } else if (hasOnlyRawStartDateTime()) {
                processUsingRawStart(originalStartEndDateTime);
            } else if (hasOnlyRawEndDateTime()) {
                processUsingRawEnd(originalStartEndDateTime);
            }
        }

        private boolean hasNoRawStartAndEndDateTime() {
            return !getRawStartDateTime().isPresent() && !getRawEndDateTime().isPresent();
        }

        private boolean hasBothRawStartAndEndDateTime() {
            return getRawStartDateTime().isPresent() && getRawEndDateTime().isPresent();
        }

        private boolean hasOnlyRawStartDateTime() {
            return getRawStartDateTime().isPresent() && !getRawEndDateTime().isPresent();
        }

        private boolean hasOnlyRawEndDateTime() {
            return !getRawStartDateTime().isPresent() && getRawEndDateTime().isPresent();
        }

        /**
         * Process the updated StartEndDateTime with the raw start and date-time with reference to the
         * original start-end date-time.
         */
        private void processUsingRawStartAndEnd(StartEndDateTime originalStartEndDateTime)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            updatedStartEndDateTime = ParserUtil.parseEditedStartEndDateTime(getRawStartDateTime(),
                    getRawEndDateTime(), originalStartEndDateTime);
        }

        /**
         * Process the updated StartEndDateTime with the raw start date-time with reference to the
         * original end date time.
         */
        private void processUsingRawStart(StartEndDateTime originalStartEndDateTime)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            ZonedDateTime startDateTime = ParserUtil.parseEditedDateTimeString(
                    getRawStartDateTime().get(), originalStartEndDateTime.getStartDateTime());
            ZonedDateTime endDateTime = originalStartEndDateTime.getEndDateTime();
            updatedStartEndDateTime = Optional.of(new StartEndDateTime(startDateTime, endDateTime));
        }

        /**
         * Process the updated StartEndDateTime with the raw end date-time with reference to the
         * original start date time.
         */
        private void processUsingRawEnd(StartEndDateTime originalStartEndDateTime)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            ZonedDateTime startDateTime = originalStartEndDateTime.getStartDateTime();
            ZonedDateTime endDateTime = ParserUtil.parseEditedDateTimeString(getRawEndDateTime().get(),
                    originalStartEndDateTime.getEndDateTime());
            updatedStartEndDateTime = Optional.of(new StartEndDateTime(startDateTime, endDateTime));
        }

        private void processTagList(ReadOnlyTask taskToEdit) {
            updatedTagList = getTagList().orElseGet(taskToEdit::getTags);
        }

        /**
         * Returns true if at least one field that is different is edited.
         */
        public boolean isAnyFieldEdited(ReadOnlyTask taskToEdit) {
            // note that the tags are added in alphabetical order and uses list compare vs set compare
            if (updatedName.equals(taskToEdit.getName())
                    && updatedDeadline.equals(taskToEdit.getDeadline())
                    && updatedStartEndDateTime.equals(taskToEdit.getStartEndDateTime())
                    && updatedTagList.equals(taskToEdit.getTags())) {
                return false;
            }
            return true;
        }

        //// methods for initializing an EditTaskDescriptor
        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public void setRawDeadline(Optional<String> rawDeadline) {
            assert rawDeadline != null;
            this.rawDeadline = rawDeadline;
        }

        public void setRawStartDateTime(Optional<String> rawStartDateTime) {
            assert rawStartDateTime != null;
            this.rawStartDateTime = rawStartDateTime;
        }

        public void setRawEndDateTime(Optional<String> rawEndDateTime) {
            assert rawEndDateTime != null;
            this.rawEndDateTime = rawEndDateTime;
        }

        public void setTagList(Optional<UniqueTagList> tagList) {
            assert tagList != null;
            this.tagList = tagList;
        }

        //// methods for getting the un-processed edited fields
        public Optional<Name> getName() {
            return name;
        }

        public Optional<String> getRawDeadline() {
            return rawDeadline;
        }

        public Optional<String> getRawStartDateTime() {
            return rawStartDateTime;
        }

        public Optional<String> getRawEndDateTime() {
            return rawEndDateTime;
        }

        public Optional<UniqueTagList> getTagList() {
            return tagList;
        }

        //// methods for getting the processed edited fields
        public Name getUpdatedName() {
            return updatedName;
        }

        public Optional<Deadline> getUpdatedDeadline() {
            return updatedDeadline;
        }
        public Optional<StartEndDateTime> getUpdatedStartEndDateTime() {
            return updatedStartEndDateTime;
        }

        public UniqueTagList getUpdatedTagList() {
            return updatedTagList;
        }
    }
}
```
###### /java/seedu/address/logic/parser/AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {
    //private DateTimeExtractor dateTimeExtractor;

    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        DateTimeExtractor dateTimeExtractor;
        try {
            dateTimeExtractor = extractDateTimes(args);
        } catch (PastDateTimeException | InvalidDurationException e) {
            return new IncorrectCommand(e.getMessage());
        }

        // TODO ArgumentTokenizer became very irrelevant in this class but is it still relevant for other classes?
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_TAG);
        argsTokenizer.tokenize(dateTimeExtractor.getProcessedArgs());
        try {
            String nameArgs = argsTokenizer.getPreamble().get();

            return new AddCommand(nameArgs, dateTimeExtractor.getProcessedDeadline(),
                    dateTimeExtractor.getProcessedStartEndDateTime(),
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG)));
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Extracts date-times from the arguments if they exist and returns a {@link DateTimeExtractor}
     * with the processed date-times if they exist.
     *
     * @param args the arguments to extract date/time from
     * @throws PastDateTimeException if any of the extracted date-times are in the past
     * @throws InvalidDurationException if a start and end date-time is found and the end date-time
     *         is before or same as the start date-time
     */
    private DateTimeExtractor extractDateTimes(String args)
            throws PastDateTimeException, InvalidDurationException {
        DateTimeExtractor dateTimeExtractor = new DateTimeExtractor(args);
        // process StartEndDateTime first because it is more likely to fail due to more constraints
        dateTimeExtractor.processStartEndDateTime();
        // constraints for deadline are looser so it is less likely to fail
        dateTimeExtractor.processDeadline();

        return dateTimeExtractor;
    }

}
```
###### /java/seedu/address/logic/parser/DateTimeExtractor.java
``` java
/**
 * Specialized class that can extract Deadline and StartEndDateTime from a command's arguments.
 */
public class DateTimeExtractor {

    private static final String MESSAGE_ALREADY_PROCESSED =
            "Processing stopped to prevent overriding of %1$s. %1$s is already processed.";

    private static final String MESSAGE_ALREADY_PROCESSED_MULTI =
            "Processing stopped to prevent overriding of %1$s and %2$s."
                    + "Both/either of them are already processed.";

    private final Logger logger = LogsCenter.getLogger(DateTimeExtractor.class);

    /**
     * Regex that matches the preamble before any argument.
     * Matches everything greedily until the next regex so any number of from and to can be included.
     * e.g. preamblePattern matches "from by to" from the String "from by to by tmr" in a Regex expression
     * containing PREAMBLE_REGEX + ARG_NAME_FROM_REGEX
     */
    private static final String PREAMBLE_REGEX = ".*";

    /**
     * Regex that matches the argument name [from].
     * Matches a single whitespace character (i.e. \t\n\x0B\f\r) in between a "from".
     * This prevents matching words such as therefrom and fromage.
     */
    private static final String ARG_NAME_FROM_REGEX = "(?<fromArg>\\sfrom\\s)";

    /**
     * Regex that matches the argument value startDateTime.
     * Matches everything greedily.
     */
    private static final String ARG_VALUE_FROM_GREEDY_REGEX = "(?<startDateTime>.+)";

    /**
     * Regex that matches the argument value startDateTime.
     * Matches everything lazily.
     */
    private static final String ARG_VALUE_FROM_LAZY_REGEX = "(?<startDateTime>.+?)";

    /**
     * Regex that matches the argument name [to].
     * Matches a single whitespace character (i.e. \t\n\x0B\f\r) in between a "to".
     * This prevents matching words such as auto and tomorrow.
     */
    private static final String ARG_NAME_TO_REGEX =  "(?<toArg>\\sto\\s)";

    /**
     * Regex that matches the argument value endDateTime.
     * Matches everything lazily.
     */
    private static final String ARG_VALUE_TO_LAZY_REGEX = "(?<endDateTime>.+?)";

    /**
     * Regex that matches the argument name [by].
     * Matches a single whitespace character (i.e. \t\n\x0B\f\r) in between a "by".
     * This prevents matching words such as baby and bypass.
     */
    private static final String ARG_NAME_BY_REGEX = "(?<byArg>\\sby\\s)";
    /**
     * Regex that matches the argument value deadline.
     * Matches everything lazily.
     */
    private static final String ARG_VALUE_BY_LAZY_REGEX = "(?<deadline>.+?)";

    // match a white space character and a tag with zero or more times
    private static final String ARG_ALL_TAGS_REGEX = "(?<tagArguments>(\\st/[^/]+)*)";
    // TODO consider changing the following format
    // match a white space character with zero or one tag;
    // "(?<tagArguments>(\\stags\\s[^/]+)?)");

    /**
     * Pattern that checks if a string contains a start and end date-time.
     * Can be used for adding or editing tasks with a start and end date/time.
     */
    public static final Pattern HAS_START_END_DATETIME_FORMAT = Pattern.compile(
            PREAMBLE_REGEX
            + ARG_NAME_FROM_REGEX
            + ARG_VALUE_FROM_GREEDY_REGEX
            + ARG_NAME_TO_REGEX
            + ARG_VALUE_TO_LAZY_REGEX // lazy match as next expression is optional
            + ARG_ALL_TAGS_REGEX);

    /**
     * Pattern that checks if a string contains a deadline date-time.
     * Can be used for adding or editing tasks with a deadline.
     */
    public static final Pattern HAS_DEADLINE_FORMAT = Pattern.compile(
            PREAMBLE_REGEX
            + ARG_NAME_BY_REGEX
            + ARG_VALUE_BY_LAZY_REGEX // lazy match as next expression is optional
            + ARG_ALL_TAGS_REGEX);

    /**
     * Pattern that checks if a string contains a start date-time.
     * Can be used for editing tasks that already has a start and end date-time.
     */
    public static final Pattern HAS_START_DATETIME_FORMAT = Pattern.compile(
            PREAMBLE_REGEX
            + ARG_NAME_FROM_REGEX
            + ARG_VALUE_FROM_LAZY_REGEX // lazy match as next expression is optional
            + ARG_ALL_TAGS_REGEX);

    /**
     * Pattern that checks if a string contains a end date-time.
     * Can be used for editing tasks that already has a start and end date-time.
     */
    public static final Pattern HAS_END_DATETIME_FORMAT = Pattern.compile(
            PREAMBLE_REGEX
            + ARG_NAME_TO_REGEX
            + ARG_VALUE_TO_LAZY_REGEX // lazy match as next expression is optional
            + ARG_ALL_TAGS_REGEX);

    /**
     * Contains the argument string after processing.
     */
    private String processedArgs;

    /**
     * Contains the Deadline after processing. Empty if does not exist.
     */
    private Optional<Deadline> deadline;
    /**
     * Contains the raw Deadline string after processing. Empty if does not exist.
     */
    private Optional<String> rawDeadline;

    /**
     * Contains the startEndDateTime after processing. Empty if does not exist.
     */
    private Optional<StartEndDateTime> startEndDateTime;
    /**
     * Contains the raw startDateTime string after processing. Empty if does not exist.
     */
    private Optional<String> rawStartDateTime;
    /**
     * Contains the raw endDateTime string after processing. Empty if does not exist.
     */
    private Optional<String> rawEndDateTime;

    public DateTimeExtractor(String args) {
        processedArgs = args;
    }

    /**
     * Returns the arguments after processing
     */
    public String getProcessedArgs() {
        return processedArgs;
    }

    /**
     * Returns the processed deadline if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<Deadline> getProcessedDeadline() {
        return deadline;
    }

    /**
     * Returns the processed raw deadline if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedRawDeadline() {
        return rawDeadline;
    }

    /**
     * Returns the processed startEndDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<StartEndDateTime> getProcessedStartEndDateTime() {
        return startEndDateTime;
    }

    /**
     * Returns the processed raw startDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedRawStartDateTime() {
        return rawStartDateTime;
    }

    /**
     * Returns the processed raw endDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedRawEndDateTime() {
        return rawEndDateTime;
    }

    /**
     * Returns if the argument value is processed.
     */
    private boolean isProcessed(Optional<?> argValue) {
        return argValue != null;
    }

    /**
     * Returns if the argument value is processed and has a value present.
     */
    private boolean isProcessedAndPresent(Optional<?> argValue) {
        return isProcessed(argValue) && argValue.isPresent();
    }

    public void processDeadline() throws PastDateTimeException {
        if (isProcessedAndPresent(rawDeadline)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "deadline"));
            return;
        }

        deadline = Optional.empty();

        processRawDeadline();

        if (!isProcessedAndPresent(rawDeadline)) {
            // TODO
            // This means what comes after by is not a date. Thus we stop here as no Deadline is found.
            // e.g. add Download song stand by me
            return;
        }

        try {
            // Note that if performance is a concern, we should process the Deadline directly instead
            // of calling processRawDeadline so to avoid parsing dates twice
            // i.e. once in processRawDeadline and once in processDeadline
            deadline = Optional.of(new Deadline(ParserUtil.parseDateTimeString(rawDeadline.get())));
        } catch (IllegalValueException e) {
            logger.severe("processDeadline() failed with invalid date when processRawDeadline"
                    + "should have ensured a valid date is provided if the raw are present.");
        }
    }

    public void processRawDeadline() {
        if (isProcessedAndPresent(rawDeadline)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "rawDeadline"));
            return;
        }

        rawDeadline = Optional.empty();

        Matcher matcher = HAS_DEADLINE_FORMAT.matcher(processedArgs);
        if (!matcher.matches()) {
            logger.info("----------------[PROCESS RAW DEADLINE][No deadline found]");
            return;
        }

        final String matchedRawDeadline = matcher.group("deadline");
        if (!ParserUtil.isDateTimeString(matchedRawDeadline)) {
            logger.info("----------------[PROCESS RAWS DEADLINE][Deadline found but not a date]");
            return;
        }
        logger.info("----------------[PROCESS RAW DEADLINE][Start:" + matchedRawDeadline + "]");

        // Note that we still do not know the exact date/time of the deadline so it can be a date in the past.
        rawDeadline = Optional.of(matchedRawDeadline);

        // Date is valid so we can extract the arguments out. However, if it is a past date,
        // the processed argument becomes invalid but a PastDateTimeException will be thrown anyway, thus
        // not allowing the command to continue.
        processedArgs = extractArguments(matcher.start("byArg"), matcher.end("deadline"));
    }

    public void processStartEndDateTime()
            throws PastDateTimeException, InvalidDurationException {

        if (isProcessedAndPresent(startEndDateTime)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "startEndDateTime"));
            return;
        }

        startEndDateTime = Optional.empty();

        processRawStartEndDateTime();

        if (!isProcessedAndPresent(rawStartDateTime) || !isProcessedAndPresent(rawEndDateTime)) {
            // TODO
            // This means that information between from and to are not dates. Thus we stop here
            // as no StartEndDateTime is found.
            // e.g. add Travel from Singapore to Malaysia
            return;
        }

        try {
            // Note that if performance is a concern, we should process the startEndDateTime directly instead
            // of calling processRawStartEndDateTime() so to avoid parsing dates twice
            // i.e. once in processRawStartEndDateTime and once in processStartEndDateTime
            startEndDateTime =
                    Optional.of(new StartEndDateTime(ParserUtil.parseDateTimeString(rawStartDateTime.get()),
                            ParserUtil.parseDateTimeString(rawEndDateTime.get())));
        } catch (IllegalValueException e) {
            logger.severe("processStartEndDateTime() failed with invalid date when processRawStartEndDateTime"
                    + "should have ensured a valid date is provided if the raw are present.");
        }
    }

    public void processRawStartEndDateTime() {
        if (isProcessedAndPresent(rawStartDateTime) || isProcessedAndPresent(rawEndDateTime)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED_MULTI, "rawStartDateTime", "rawEndDateTime"));
            return;
        }

        rawStartDateTime = Optional.empty();
        rawEndDateTime = Optional.empty();

        Matcher matcher = HAS_START_END_DATETIME_FORMAT.matcher(processedArgs);
        if (!matcher.matches()) {
            logger.info("----------------[PROCESS RAWSTARTENDDATETIME][No Start and End Date Time found]");
            return;
        }

        final String matchedStartDateTime = matcher.group("startDateTime");
        final String matchedEndDateTime = matcher.group("endDateTime");
        if (!ParserUtil.isDateTimeString(matchedStartDateTime)
                || !ParserUtil.isDateTimeString(matchedEndDateTime)) {
            logger.info("----------------[PROCESS RAWSTARTENDDATETIME][Start and End Date/Time found "
                    + "but both/either not a date]");
            return;
        }
        logger.info("----------------[PROCESS RAWSTARTENDDATETIME][Start:"
                + matchedStartDateTime + "]");
        logger.info("----------------[PROCESS RAWSTARTENDDATETIME][End: "
                + matchedEndDateTime + "]");

        // Note that we still do not know the exact date/time of the dates so they can be dates in the past.
        // We also do not know if the end date will be after the start date.
        rawStartDateTime = Optional.of(matchedStartDateTime);
        rawEndDateTime = Optional.of(matchedEndDateTime);

        // Dates are valid so we can extract the arguments out. However, if there is any past date,
        // the processed argument becomes invalid but a PastDateTimeException will be thrown anyway, thus
        // not allowing the command to continue. Similarly, a InvalidDurationException will be thrown if the
        // End Date comes after the Start Date.
        processedArgs = extractArguments(matcher.start("fromArg"), matcher.end("endDateTime"));
    }

    public void processRawStartDateTime() {
        if (isProcessedAndPresent(rawStartDateTime)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "rawStartDateTime"));
            return;
        }
        // note the above will make edit 4 from Friday fail previously

        rawStartDateTime = Optional.empty();

        Matcher matcher = HAS_START_DATETIME_FORMAT.matcher(processedArgs);
        if (!matcher.matches()) {
            logger.info("----------------[PROCESS RAWSTARTDATETIME][No Start Date/Time found]");
            return;
        }

        final String matchedStartDateTime = matcher.group("startDateTime");
        if (!ParserUtil.isDateTimeString(matchedStartDateTime)) {
            logger.info("----------------[PROCESS RAWSTARTDATETIME][Start Date/Time found but not a date]");
            return;
        }
        logger.info("----------------[PROCESS RAWSTARTDATETIME][Start:"
                + matchedStartDateTime + "]");

        // Note that we still do not know the exact date/time of the date so it can be a date in the past.
        // We also do not know if the end date will be after the start date.
        rawStartDateTime = Optional.of(matchedStartDateTime);

        // Date is valid so we can extract the arguments out. However, if there is any past date,
        // the processed argument becomes invalid but a PastDateTimeException will be thrown anyway, thus
        // not allowing the command to continue. Similarly, an InvalidDurationException will be thrown if the
        // End Date comes after the Start Date.
        processedArgs = extractArguments(matcher.start("fromArg"), matcher.end("startDateTime"));
    }

    public void processRawEndDateTime() {
        if (isProcessedAndPresent(rawEndDateTime)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "rawEndDateTime"));
            return;
        }

        rawEndDateTime = Optional.empty();

        Matcher matcher = HAS_END_DATETIME_FORMAT.matcher(processedArgs);
        if (!matcher.matches()) {
            logger.info("----------------[PROCESS RAWENDDATETIME][No End Date/Time found]");
            return;
        }

        final String matchedEndDateTime = matcher.group("endDateTime");
        if (!ParserUtil.isDateTimeString(matchedEndDateTime)) {
            logger.info("----------------[PROCESS RAWENDDATETIME][End Date/Time found but not a date]");
            return;
        }
        logger.info("----------------[PROCESS RAWENDDATETIME][End:"
                + matchedEndDateTime + "]");

        // Note that we still do not know the exact date/time of the date so it can be a date in the past.
        // We also do not know if the end date will be after the start date.
        rawEndDateTime = Optional.of(matchedEndDateTime);

        // Date is valid so we can extract the arguments out. However, if there is any past date,
        // the processed argument becomes invalid but a PastDateTimeException will be thrown anyway, thus
        // not allowing the command to continue. Similarly, an InvalidDurationException will be thrown if the
        // End Date comes after the Start Date.
        processedArgs = extractArguments(matcher.start("toArg"), matcher.end("endDateTime"));
    }

    /**
     * Returns the processed arguments that have the arguments specified by
     * {@code startIndex} to {@code endIndex} extracted out.
     */
    private String extractArguments(int startIndex, int endIndex) {
        return StringUtil.replace(processedArgs, startIndex, endIndex, "");
    }

}
```
###### /java/seedu/address/logic/parser/EditCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        DateTimeExtractor dateTimeExtractor = extractDateTimes(args);

        // TODO ArgumentTokenizer became very irrelevant in this class but is it still relevant for other classes?
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_TAG);
        argsTokenizer.tokenize(dateTimeExtractor.getProcessedArgs());
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        try {
            editTaskDescriptor.setName(ParserUtil.parseName(preambleFields.get(1)));

            // set raw dates as they are to be referenced from the task's previous dates
            editTaskDescriptor.setRawDeadline(dateTimeExtractor.getProcessedRawDeadline());
            editTaskDescriptor.setRawStartDateTime(dateTimeExtractor.getProcessedRawStartDateTime());
            editTaskDescriptor.setRawEndDateTime(dateTimeExtractor.getProcessedRawEndDateTime());

            editTaskDescriptor.setTagList(parseTagsForEdit(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        return new EditCommand(index.get(), editTaskDescriptor);
    }

    /**
     * Extracts date-times from the arguments if they exist and returns a {@link DateTimeExtractor} with the
     * processed raw date-times if they exist.
     *
     * @param args the arguments to extract date/time from
     */
    private DateTimeExtractor extractDateTimes(String args) {
        // TODO extract comments for testing
        DateTimeExtractor dateTimeExtractor = new DateTimeExtractor(args);
        // process StartEndDateTime first because it is more likely to fail due to more constraints
        // e.g. from [some date to some date] will be parsed as a single date if we process only the
        // startDateTime first
        // Pass rose from Uncle to Jane by tmr
        // we should not return an error because that case is a valid task
        dateTimeExtractor.processRawStartEndDateTime();
        // constraints for deadline are looser so it is less likely to fail
        dateTimeExtractor.processRawDeadline();
        // TODO process from later
        // because for example edit 10 test by 2 days from 25 Apr
        // note again that edit 10 test by 2 days later from 25 Apr will ignore the from later
        dateTimeExtractor.processRawStartDateTime();
        dateTimeExtractor.processRawEndDateTime();

        return dateTimeExtractor;
    }

```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
    private static Parser dateTimeParser = new Parser(TimeZone.getDefault()); // TODO timezones
    // TODO decide if this is the right class
    public static final DateTimeFormatter DATE_TIME_FORMAT = DateTimeFormatter.ISO_DATE_TIME;

```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
    /**
     * TODO comments. For new deadlines
     * @param deadline
     * @return
     * @throws PastDateTimeException
     * @throws IllegalValueException
     */
    public static Optional<Deadline> parseNewDeadline(Optional<String> deadline)
            throws PastDateTimeException, IllegalValueException {
        assert deadline != null;
        return deadline.isPresent() ? Optional.of(new Deadline(parseDateTimeString(deadline.get()))) : Optional.empty();
    }

    /**
     * TODO Comments. For Edited deadlines
     * @param rawDeadline
     * @param previousDeadline
     * @return
     * @throws PastDateTimeException
     * @throws IllegalValueException
     */
    public static Optional<Deadline> parseEditedDeadline(Optional<String> rawDeadline, Deadline previousDeadline)
            throws PastDateTimeException, IllegalValueException {
        assert rawDeadline != null;
        if (rawDeadline.isPresent()) {
            return Optional.of(new Deadline(parseEditedDateTimeString(rawDeadline.get(), previousDeadline.getValue())));
        } else {
            return Optional.empty();
        }
    }

    public static Optional<StartEndDateTime> parseEditedStartEndDateTime(Optional<String> startDateTime,
            Optional<String> endDateTime, StartEndDateTime previousStartEndDateTime)
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {
        assert startDateTime != null && endDateTime != null;

        if (!startDateTime.isPresent() || !endDateTime.isPresent()) {
            // TODO If it is malformed should we just ignore or should we do further checks and throw an error?
            return Optional.empty();
        }

        StartEndDateTime startEndDateTime = new StartEndDateTime(
                parseEditedDateTimeString(startDateTime.get(), previousStartEndDateTime.getStartDateTime()),
                parseEditedDateTimeString(endDateTime.get(), previousStartEndDateTime.getEndDateTime()));

        return Optional.of(startEndDateTime);
    }

    public static Optional<StartEndDateTime> parseNewStartEndDateTime(Optional<String> startDateTime,
            Optional<String> endDateTime)
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {
        assert startDateTime != null && endDateTime != null;

        if (!startDateTime.isPresent() || !endDateTime.isPresent()) {
            // TODO If it is malformed should we just ignore or should we do further checks and throw an error?
            return Optional.empty();
        }

        StartEndDateTime startEndDateTime = new StartEndDateTime(parseDateTimeString(startDateTime.get()),
                                                                 parseDateTimeString(endDateTime.get()));

        return Optional.of(startEndDateTime);
    }

    public static ZonedDateTime parseEditedDateTimeString(String dateTime, ZonedDateTime previousDate)
            throws IllegalValueException {
        // TODO extract commonalities from parseDateTimeString
        // TODO check if only one group and only one date from list (date alternatives)
        List<DateGroup> groups = dateTimeParser.parse(dateTime);
        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            if (dates.size() > 0) {
                // 24 hours later what happens
                System.out.println("Date inferred: " + group.isDateInferred());
                System.out.println("Time inferred: " + group.isTimeInferred());
                System.out.println("Date type: " + group.getSyntaxTree().getChild(0).getChild(0));
                String dateType = group.getSyntaxTree().getChild(0).getChild(0).getText();
                if (dateType.equals("RELATIVE_DATE") || dateType.equals("RELATIVE_TIME")) {
                    // such as 24 hours later
                    // such as 2 days later
                    // Relative dates should always be relative to current date not other dates
                    // special cases such as 2 days after 25 Apr also works
                    // but cases such as 2 hours after 25 Apr 8pm does not work
                    // Neither does cases such as 2 hours after 25 Apr 8pm work
                    System.out.println("Relative do nothing!");
                } else {
                    if (group.isDateInferred()) {
                        System.out.println("Date inferred");
                        // TODO do timezones properly
                        // note Natty does not support SGT so we use offset but this means timezone info
                        // such as daylight saving time adjustments are lost
                        String extractedDate = new SimpleDateFormat("HH:mm:ss Z").format(dates.get(0));
                        //System.out.println(new SimpleDateFormat("HH:mm:ss z").format(dates.get(0)));
                        //System.out.println(new SimpleDateFormat("HH:mm:ss Z").format(dates.get(0)));
                        //System.out.println(new SimpleDateFormat("HH:mm:ss zz").format(dates.get(0)));
                        List<DateGroup> groupsRedone =
                                dateTimeParser.parse(extractedDate, Date.from(previousDate.toInstant()));
                        Date newDate = groupsRedone.get(0).getDates().get(0);
                        return ZonedDateTime.ofInstant(newDate.toInstant(), ZoneId.systemDefault());
                    }
                    if (group.isTimeInferred()) {
                        System.out.println("Time inferred");
                        // TODO using SimpleDateFormat cos old date
                        String extractedDate = new SimpleDateFormat("yyyy-MM-dd").format(dates.get(0));
                        List<DateGroup> groupsRedone =
                                dateTimeParser.parse(extractedDate, Date.from(previousDate.toInstant()));
                        Date newDate = groupsRedone.get(0).getDates().get(0);
                        return ZonedDateTime.ofInstant(newDate.toInstant(), ZoneId.systemDefault());
                    }
                }
                // TODO comment Avoid old Date class where possible format
                Instant instant = dates.get(0).toInstant();
                ZoneId zoneId = ZoneId.systemDefault();

                // TODO use a ZonedDateTime so user can see time in his timezone, perhaps
                // Instant can be used where possible and only when reading input and output from user
                // we use ZonedDateTime
                ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, zoneId);
                return zonedDateTime;
            }
        }
        throw new IllegalValueException(dateTime + " is not a valid date/time.");
    }

    // TODO notice the inconsistencies of the parsing class, maybe need to change this
    /**
     * Parses Date strings into a {@code ZonedDateTime}.
     */
    public static ZonedDateTime parseDateTimeString(String dateTime) throws IllegalValueException {
        List<DateGroup> groups = dateTimeParser.parse(dateTime);
        // TODO check if only one group and only one date from list (date alternatives)
        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            if (dates.size() > 0) {
                // TODO comment Avoid old Date class where possible format
                Instant instant = dates.get(0).toInstant();
                ZoneId zoneId = ZoneId.systemDefault();

                // TODO use a ZonedDateTime so user can see time in his timezone, perhaps
                // Instant can be used where possible and only when reading input and output from user
                // we use ZonedDateTime
                ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, zoneId);
                return zonedDateTime;
            }
        }
        throw new IllegalValueException(dateTime + " is not a valid date/time.");
    }

    // TODO maybe doesn't belong in ParserUtil
    /**
     * Returns if Date strings are valid DateTimes.
     */
    public static boolean isDateTimeString(String dateTime) {
        List<DateGroup> groups = dateTimeParser.parse(dateTime);
        // TODO check if only one group and only one date from list (date alternatives)
        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            if (dates.size() > 0) {
                // TODO note that the size should be == 1 because it shouldn't be more than one date
                return true;
            }
        }
        return false;
    }
}
```
###### /java/seedu/address/model/task/Deadline.java
``` java
public class Deadline {
    public static final String MESSAGE_DEADLINE_CONSTRAINTS = "Deadline should not be in the past";

    private ZonedDateTime dateTime;

    /**
     * Constructs a new Deadline with the given DateTime.
     *
     * @param dateTime the DateTime to specify for the deadline
     * @throws PastDateTimeException if {@code dateTime} is before the current DateTime
     */
    public Deadline(ZonedDateTime dateTime) throws PastDateTimeException {
        this(dateTime, false);
    }

    /**
     * Constructs a new Deadline with the given DateTime. Ignores checking for dates in the past if
     * {@code ignorePast} is true.
     *
     * @param dateTime the DateTime to specify for the deadline
     * @param allowPastDateTime ignore checking if {@code dateTime} is in the past. Avoid setting
     *        to true except for cases such as loading from storage
     * @throws PastDateTimeException if {@code dateTime} is before the current DateTime and
     *         {@code allowPastDateTime} is {@code false}
     */
    public Deadline(ZonedDateTime dateTime, boolean allowPastDateTime) throws PastDateTimeException {
        assert dateTime != null;

        if (!allowPastDateTime) {
            if (dateTime.isBefore(ZonedDateTime.now())) {
                throw new PastDateTimeException(MESSAGE_DEADLINE_CONSTRAINTS);
            }
        }

        this.dateTime = dateTime;
    }

    public ZonedDateTime getValue() {
        return dateTime;
    }

    @Override
    public String toString() {
        return dateTime.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final Deadline other = (Deadline) o;

        return Objects.equals(getValue(), other.getValue());
    }

    @Override
    public int hashCode() {
        return dateTime.hashCode();
    }
}
```
###### /java/seedu/address/model/task/exceptions/IllegalDateTimeException.java
``` java
/**
 * Signals that some given DateTime(s) does not fulfill some date related constraints.
 */
public abstract class IllegalDateTimeException extends Exception {

    /**
     * @param message should contain relevant information on the failed date related constraint(s)
     */
    public IllegalDateTimeException(String message) {
        super(message);
    }

}
```
###### /java/seedu/address/model/task/exceptions/InvalidDurationException.java
``` java
/**
 * Signals that the duration between two dates are negative or zero, thus constituting an invalid duration.
 */
public class InvalidDurationException extends IllegalDateTimeException {

    /**
     * @param message should contain relevant information on how the two dates have an
     *        invalid duration between them
     */
    public InvalidDurationException(String message) {
        super(message);
    }

}
```
###### /java/seedu/address/model/task/exceptions/PastDateTimeException.java
``` java
/**
 * Signals that a date constructed was in the past.
 */
public class PastDateTimeException extends IllegalDateTimeException {

    /**
     * @param message should contain relevant information on why the date should not be in the past.
     */
    public PastDateTimeException(String message) {
        super(message);
    }

}
```
###### /java/seedu/address/model/task/ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final ReadOnlyTask other = (ReadOnlyTask) o;

        return Objects.equals(getName(), other.getName())
                && Objects.equals(getDeadline(), other.getDeadline())
                && Objects.equals(getStartEndDateTime(), other.getStartEndDateTime());
        // TODO tags should actually be checked because that's how equals should usually function
        // However, the equals here is used to check for duplicates and is not really consistent
        // with how equals behave. Thus to further investigate.
        // Furthermore, this current implementation does not allow Tasks with same name to go through
        // if there are no deadlines or start and end date time. Probably would be better to remove
        // the duplicate task exception in this case.
    }

    /**
     * Formats the task as text, showing all fields.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        buildNameString(builder);
        buildDeadlineString(builder);
        buildStartEndDateTimeString(builder);
        buildTagsString(builder);

        return builder.toString();
    }

    default void buildNameString(final StringBuilder builder) {
        builder.append(getName());
    }

    default void buildDeadlineString(final StringBuilder builder) {
        // TODO don't include milliseconds in toString output
        builder.append(" Deadline: ");
        builder.append(getDeadline().isPresent() ? getDeadline().get().toString() : "none");
    }

    default void buildStartEndDateTimeString(final StringBuilder builder) {
        // TODO don't include milliseconds in toString output
        if (getStartEndDateTime().isPresent()) {
            builder.append(" ");
            builder.append(getStartEndDateTime().get().toString());
        } else {
            builder.append(" Start Date: none ");
            builder.append(" End Date: none ");
        }
    }

    default void buildTagsString(final StringBuilder builder) {
        builder.append(" Tags: ");
        getTags().forEach(builder::append);
    }

}
```
###### /java/seedu/address/model/task/StartEndDateTime.java
``` java
public class StartEndDateTime {
    public static final String MESSAGE_STARTDATETIME_CONSTRAINTS = "Start Date/Time should not be in the past";
    public static final String MESSAGE_ENDDATETIME_CONSTRAINTS = "End Date/Time should not be in the past";
    public static final String MESSAGE_STARTENDDATETIME_CONSTRAINTS = "End Date/Time must be after Start Date/Time";

    private ZonedDateTime startDateTime;
    private ZonedDateTime endDateTime;

    /**
     * Constructs a new StartDateTime with the given start and end date-time.
     *
     * @param startDateTime the start date-time
     * @param endDateTime the end date-time
     * @throws PastDateTimeException if any of the date-times are before the current date-time
     * @throws InvalidDurationException if the end date-time is before or same as the start date-time
     */
    public StartEndDateTime(ZonedDateTime startDateTime, ZonedDateTime endDateTime)
            throws PastDateTimeException, InvalidDurationException {
        this(startDateTime, endDateTime, false);
    }

    /**
     * Constructs a new StartEndDateTime with the given start and end date-time. Ignores checking for
     * dates in the past if {@code ignorePast} is true.
     *
     * @param startDateTime the start date-time
     * @param endDateTime the end date-time
     * @param allowPastDateTime ignore checking if date-times are in the past. Avoid setting to true
     *        except for special cases such as loading from storage
     * @throws PastDateTimeException if any of the date-times are before the current date-time and
     *         {@code allowPastDateTime} is {@code false}
     * @throws InvalidDurationException if the end date-time is before or same as the start date-time
     */
    public StartEndDateTime(ZonedDateTime startDateTime, ZonedDateTime endDateTime, boolean allowPastDateTime)
            throws PastDateTimeException, InvalidDurationException {
        assert startDateTime != null && endDateTime != null;

        if (!allowPastDateTime) {
            // Keep a snapshot of current date time otherwise startDateTime might be after the current date but
            // endDateTime might be before the current date due to a different currentDateTime used
            ZonedDateTime currentDateTime = ZonedDateTime.now();

            if (startDateTime.isBefore(currentDateTime)) {
                throw new PastDateTimeException(MESSAGE_STARTDATETIME_CONSTRAINTS);
            }

            if (endDateTime.isBefore(currentDateTime)) {
                throw new PastDateTimeException(MESSAGE_ENDDATETIME_CONSTRAINTS);
            }
        }

        // The end date time must be after the start date time, but not same or before
        if (!endDateTime.isAfter(startDateTime)) {
            throw new InvalidDurationException(MESSAGE_STARTENDDATETIME_CONSTRAINTS);
        }

        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
    }

    public ZonedDateTime getStartDateTime() {
        return startDateTime;
    }

    public ZonedDateTime getEndDateTime() {
        return endDateTime;
    }

    @Override
    public String toString() {
        return "Start Date: " + startDateTime.toString() + " End Date: " + endDateTime.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final StartEndDateTime other = (StartEndDateTime) o;

        return Objects.equals(getStartDateTime(), other.getStartDateTime())
                && Objects.equals(getEndDateTime(), other.getEndDateTime());
    }

    @Override
    public int hashCode() {
        return Objects.hash(startDateTime, endDateTime);
    }

}
```
###### /java/seedu/address/model/task/Task.java
``` java
    @Override
    public Optional<Deadline> getDeadline() {
        return deadline;
    }

    /**
     * Only allow changing the {@link StartEndDateTime} if there is actually a value (not {@link Optional}).
     */
    public void setDeadline(Deadline dateTime) {
        assert dateTime != null;
        this.deadline = Optional.of(dateTime);
    }

    @Override
    public Optional<StartEndDateTime> getStartEndDateTime() {
        return startEndDateTime;
    }

    /**
     * Only allow changing the {@link StartEndDateTime} if there is actually a value (not {@link Optional}).
     */
    public void setStartEndDateTime(StartEndDateTime startEndDateTime) {
        assert startEndDateTime != null;
        this.startEndDateTime = Optional.of(startEndDateTime);
    }

```
###### /java/seedu/address/model/task/Task.java
``` java
    /**
     * Updates this task with the details of {@code replacement} using a "shallow copy" of the data. Refer to
     * {@link Object#clone()} for more information about shallow copy.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        // Note that we are shallow copying data replacement's data so replacement should not be
        // reused anymore. Otherwise modify this method to do a deep copy

        setName(replacement.getName());

        // Note that we are reusing the same Optional from replacement directly
        // Hence we are not using the setter method which only accepts Deadline
        deadline = replacement.getDeadline();
        // Similarly for startEndDateTime we are reusing same Optional
        startEndDateTime = replacement.getStartEndDateTime();

        setTags(replacement.getTags());
    }

```
###### /java/seedu/address/model/util/SampleDataUtil.java
``` java
    public static Task[] getSampleTasks() {
        try {
            // TODO improve variety of test cases
            return new Task[] {
                new Task(new Name("EE2021"), Optional.of(new Deadline(ZonedDateTime.now().plusDays(3))),
                         Optional.empty(), new UniqueTagList("homework")),
                new Task(new Name("MA1506"), Optional.empty(), Optional.empty(),
                         new UniqueTagList("killer", "revision")),
                new Task(new Name("CS2103 Project"), Optional.empty(), Optional.empty(), new UniqueTagList("Help")),
                new Task(new Name("PC1222 Lecture"), Optional.empty(), Optional.empty(), new UniqueTagList("lecture")),
                new Task(new Name("GEH1027 Lecture"), Optional.empty(), Optional.empty(), new UniqueTagList("lecture")),
                new Task(new Name("HOHO Time"), Optional.empty(), Optional.empty(), new UniqueTagList("LMAO"))
            };
        } catch (PastDateTimeException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }

```
###### /java/seedu/address/storage/XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(name = "name", required = true)
    private String nameElement;

    @XmlElement(name = "deadline")
    private String deadlineElement;

    @XmlElement(name = "startDate")
    private String startDateTimeElement;

    @XmlElement(name = "endDate")
    private String endDateTimeElement;

    @XmlElement(name = "tag")
    private List<XmlAdaptedTag> tagElements = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        setNameElement(source.getName().value);

        setDeadlineElementIfPresent(source.getDeadline());
        // the start and end date elements must be set together because they cannot exist separately
        setStartEndDateElementsIfPresent(source.getStartEndDateTime());

        // TODO do I need to check if Deadline exists then StartEndDateTime cannot exists and vice versa

        setTagElement(source.getTags());
    }

    /**
     * Sets the XmlElement name to the source task's name
     */
    private void setNameElement(String sourceName) {
        nameElement = sourceName;
    }

    /**
     * Sets the XmlElement name to the source task's deadline if it is present
     */
    private void setDeadlineElementIfPresent(Optional<Deadline> sourceDeadline) {
        if (sourceDeadline.isPresent()) {
            Deadline deadline = sourceDeadline.get();
            deadlineElement = deadline.getValue().format(ParserUtil.DATE_TIME_FORMAT);
        }
    }

    /**
     * Sets the XmlElement startDate and endDate to the source task's start and dates if they are present
     */
    private void setStartEndDateElementsIfPresent(Optional<StartEndDateTime> sourceStartEndDateTime) {
        if (sourceStartEndDateTime.isPresent()) {
            StartEndDateTime startEndDateTime = sourceStartEndDateTime.get();
            startDateTimeElement = startEndDateTime.getStartDateTime().format(ParserUtil.DATE_TIME_FORMAT);
            endDateTimeElement = startEndDateTime.getEndDateTime().format(ParserUtil.DATE_TIME_FORMAT);
        }
    }

    /**
     * Sets each tag XmlElement to the source task's tags from its unique tag list
     */
    private void setTagElement(UniqueTagList sourceTagList) {
        tagElements = new ArrayList<>();
        for (Tag tag : sourceTagList) {
            tagElements.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     * @throws InvalidDurationException if the end DateTime is before or same as the start DateTime
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException, PastDateTimeException, InvalidDurationException {
        // TODO get seems to not be a good name, as it is usually used for getters
        final Name name = getNameFromXmlElement();
        final Optional<Deadline> deadline = getDeadlineFromXmlElement();
        final Optional<StartEndDateTime> startEndDateTime = getStartEndDateTimeFromXmlElement();
        final UniqueTagList tagList = getTagListFromXmlElement();

        return new Task(name, deadline, startEndDateTime, tagList);
    }

    /**
     * Returns a Name created from the XmlElement.
     * @throws IllegalValueException if the name does not fulfill the name's constraints
     */
    private Name getNameFromXmlElement() throws IllegalValueException {
        return new Name(nameElement);
    }

    /**
     * Returns an {@link Optional} wrapping the {@link Deadline} created from the XmlElement.
     * If the XmlElement for deadline does not exist, returns an empty {@link Optional}.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     */
    private Optional<Deadline> getDeadlineFromXmlElement() throws PastDateTimeException {
        // return empty if xml element does not exist
        if (deadlineElement == null) {
            return Optional.empty();
        }
        // construct Deadline with allowPastDateTime set to true because this is loaded from storage
        Deadline deadline = new Deadline(ZonedDateTime.parse(deadlineElement, ParserUtil.DATE_TIME_FORMAT), true);
        return Optional.of(deadline);
    }

    /**
     * Returns an {@link Optional} wrapping the {@link StartEndDateTime} created from the two XmlElements.
     * If any of the two XmlElements for StartEndDateTime does not exist, returns an empty {@link Optional}.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     * @throws InvalidDurationException if the end DateTime is before or same as the start DateTime
     */
    private Optional<StartEndDateTime> getStartEndDateTimeFromXmlElement()
            throws PastDateTimeException, InvalidDurationException {
        // return empty if either xml element does not exist
        if (startDateTimeElement == null || endDateTimeElement == null) {
            return Optional.empty();
        }
        ZonedDateTime startDateTime = ZonedDateTime.parse(startDateTimeElement, ParserUtil.DATE_TIME_FORMAT);
        ZonedDateTime endDateTime = ZonedDateTime.parse(endDateTimeElement, ParserUtil.DATE_TIME_FORMAT);
        // construct StartEndDateTime with allowPastDateTime set to true because this is loaded from storage
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime, true);
        return Optional.of(startEndDateTime);
    }

    /**
     * Returns a UniqueTagList of the tags created from every tag XmlElement for the Task
     * @throws IllegalValueException if any of the tags from the XML is invalid
     * @throws DuplicateTagException if any of the tags are duplicates
     */
    private UniqueTagList getTagListFromXmlElement() throws IllegalValueException, DuplicateTagException {
        final List<Tag> tags = new ArrayList<>();
        for (XmlAdaptedTag adaptedTag : tagElements) {
            tags.add(adaptedTag.toModelType());
        }
        return new UniqueTagList(tags);
    }
}
```
###### /java/seedu/address/storage/XmlSerializableTaskList.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        final ObservableList<Task> tasks = this.tasks.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (PastDateTimeException e) {
                // this should never happen as we loaded from storage
                // TODO should we handle this differently or earlier?
                return null;
            } catch (InvalidDurationException e) {
                // TODO should we handle this earlier?
                return null;
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(tasks);
    }

```
